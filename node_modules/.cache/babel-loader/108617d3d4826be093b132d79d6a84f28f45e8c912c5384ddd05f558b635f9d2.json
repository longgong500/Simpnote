{"ast":null,"code":"import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isGraceNote, isStaveNote, isStemmableNote, isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L(...args) {\n  if (Articulation.DEBUG) log('Vex.Flow.Articulation', args);\n}\nconst {\n  ABOVE,\n  BELOW\n} = Modifier.Position;\nfunction roundToNearestHalf(mathFn, value) {\n  return mathFn(value / 0.5) * 0.5;\n}\nfunction isWithinLines(line, position) {\n  return position === ABOVE ? line <= 5 : line >= 1;\n}\nfunction getRoundingFunction(line, position) {\n  if (isWithinLines(line, position)) {\n    if (position === ABOVE) {\n      return Math.ceil;\n    } else {\n      return Math.floor;\n    }\n  } else {\n    return Math.round;\n  }\n}\nfunction snapLineToStaff(canSitBetweenLines, line, position, offsetDirection) {\n  const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n  const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n  const onStaffLine = snappedLine % 1 === 0;\n  if (canSnapToStaffSpace && onStaffLine) {\n    const HALF_STAFF_SPACE = 0.5;\n    return snappedLine + HALF_STAFF_SPACE * -offsetDirection;\n  } else {\n    return snappedLine;\n  }\n}\nconst isStaveOrGraceNote = note => isStaveNote(note) || isGraceNote(note);\nfunction getTopY(note, textLine) {\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stemBaseY;\n      }\n    } else {\n      return Math.min(...note.getYs());\n    }\n  } else if (isTabNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return note.checkStave().getYForTopText(textLine);\n      }\n    } else {\n      return note.checkStave().getYForTopText(textLine);\n    }\n  } else {\n    throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n}\nfunction getBottomY(note, textLine) {\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemBaseY;\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return Math.max(...note.getYs());\n    }\n  } else if (isTabNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return note.checkStave().getYForBottomText(textLine);\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return note.checkStave().getYForBottomText(textLine);\n    }\n  } else {\n    throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n}\nfunction getInitialOffset(note, position) {\n  const isOnStemTip = position === ABOVE && note.getStemDirection() === Stem.UP || position === BELOW && note.getStemDirection() === Stem.DOWN;\n  if (isStaveOrGraceNote(note)) {\n    if (note.hasStem() && isOnStemTip) {\n      return 0.5;\n    } else {\n      return 1;\n    }\n  } else {\n    if (note.hasStem() && isOnStemTip) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n}\nclass Articulation extends Modifier {\n  static get CATEGORY() {\n    return \"Articulation\";\n  }\n  static format(articulations, state) {\n    if (!articulations || articulations.length === 0) return false;\n    const margin = 0.5;\n    let maxGlyphWidth = 0;\n    const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), defined(articulation.glyph.getMetrics().height) / 10 + margin);\n    articulations.forEach(articulation => {\n      const note = articulation.checkAttachedNote();\n      maxGlyphWidth = Math.max(note.getGlyphProps().getWidth(), maxGlyphWidth);\n      let lines = 5;\n      const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n      let stemHeight = 0;\n      if (isStemmableNote(note)) {\n        const stem = note.getStem();\n        if (stem) {\n          stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n        }\n      }\n      const stave = note.getStave();\n      if (stave) {\n        lines = stave.getNumLines();\n      }\n      if (articulation.getPosition() === ABOVE) {\n        let noteLine = note.getLineNumber(true);\n        if (stemDirection === Stem.UP) {\n          noteLine += stemHeight;\n        }\n        let increment = getIncrement(articulation, state.top_text_line, ABOVE);\n        const curTop = noteLine + state.top_text_line + 0.5;\n        if (!articulation.articulation.between_lines && curTop < lines) {\n          increment += lines - curTop;\n        }\n        articulation.setTextLine(state.top_text_line);\n        state.top_text_line += increment;\n      } else if (articulation.getPosition() === BELOW) {\n        let noteLine = Math.max(lines - note.getLineNumber(), 0);\n        if (stemDirection === Stem.DOWN) {\n          noteLine += stemHeight;\n        }\n        let increment = getIncrement(articulation, state.text_line, BELOW);\n        const curBottom = noteLine + state.text_line + 0.5;\n        if (!articulation.articulation.between_lines && curBottom < lines) {\n          increment += lines - curBottom;\n        }\n        articulation.setTextLine(state.text_line);\n        state.text_line += increment;\n      }\n    });\n    const width = articulations.map(articulation => articulation.getWidth()).reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n    const overlap = Math.min(Math.max(width - maxGlyphWidth, 0), Math.max(width - (state.left_shift + state.right_shift), 0));\n    state.left_shift += overlap / 2;\n    state.right_shift += overlap / 2;\n    return true;\n  }\n  static easyScoreHook({\n    articulations\n  }, note, builder) {\n    if (!articulations) return;\n    const articNameToCode = {\n      staccato: 'a.',\n      tenuto: 'a-',\n      accent: 'a>'\n    };\n    articulations.split(',').map(articString => articString.trim().split('.')).map(([name, position]) => {\n      const artic = {\n        type: articNameToCode[name]\n      };\n      if (position) artic.position = Modifier.PositionString[position];\n      return builder.getFactory().Articulation(artic);\n    }).map(artic => note.addModifier(artic, 0));\n  }\n  constructor(type) {\n    super();\n    this.type = type;\n    this.position = ABOVE;\n    this.render_options = {\n      font_scale: Tables.NOTATION_FONT_SCALE\n    };\n    this.reset();\n  }\n  reset() {\n    this.articulation = Tables.articulationCodes(this.type);\n    if (!this.articulation) {\n      this.articulation = {\n        code: this.type,\n        between_lines: false\n      };\n      if (this.type.endsWith('Above')) this.position = ABOVE;\n      if (this.type.endsWith('Below')) this.position = BELOW;\n    }\n    const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n    this.glyph = new Glyph(code !== null && code !== void 0 ? code : '', this.render_options.font_scale);\n    defined(this.glyph, 'ArgumentError', `Articulation not found: ${this.type}`);\n    this.setWidth(defined(this.glyph.getMetrics().width));\n  }\n  setBetweenLines(betweenLines = true) {\n    this.articulation.between_lines = betweenLines;\n    return this;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const index = this.checkIndex();\n    const {\n      position,\n      glyph,\n      text_line: textLine\n    } = this;\n    const canSitBetweenLines = this.articulation.between_lines;\n    const stave = note.checkStave();\n    const staffSpace = stave.getSpacingBetweenLines();\n    const isTab = isTabNote(note);\n    const {\n      x\n    } = note.getModifierStartXY(position, index);\n    const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n    const initialOffset = getInitialOffset(note, position);\n    const padding = Tables.currentMusicFont().lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n    let y = {\n      [ABOVE]: () => {\n        glyph.setOrigin(0.5, 1);\n        const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;\n      },\n      [BELOW]: () => {\n        glyph.setOrigin(0.5, 0);\n        const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;\n      }\n    }[position]();\n    if (!isTab) {\n      const offsetDirection = position === ABOVE ? -1 : +1;\n      const noteLine = note.getKeyProps()[index].line;\n      const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n      const articLine = distanceFromNote + Number(noteLine);\n      const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n      if (isWithinLines(snappedLine, position)) glyph.setOrigin(0.5, 0.5);\n      y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + padding * offsetDirection;\n    }\n    L(`Rendering articulation at (x: ${x}, y: ${y})`);\n    glyph.render(ctx, x, y);\n  }\n}\nArticulation.DEBUG = false;\nArticulation.INITIAL_OFFSET = -0.5;\nexport { Articulation };","map":{"version":3,"names":["Glyph","Modifier","Stem","Tables","isGraceNote","isStaveNote","isStemmableNote","isTabNote","defined","log","RuntimeError","L","args","Articulation","DEBUG","ABOVE","BELOW","Position","roundToNearestHalf","mathFn","value","isWithinLines","line","position","getRoundingFunction","Math","ceil","floor","round","snapLineToStaff","canSitBetweenLines","offsetDirection","snappedLine","canSnapToStaffSpace","onStaffLine","HALF_STAFF_SPACE","isStaveOrGraceNote","note","getTopY","textLine","stemDirection","getStemDirection","topY","stemTipY","baseY","stemBaseY","getStemExtents","hasStem","UP","min","getYs","checkStave","getYForTopText","getBottomY","max","getYForBottomText","getInitialOffset","isOnStemTip","DOWN","CATEGORY","format","articulations","state","length","margin","maxGlyphWidth","getIncrement","articulation","glyph","getMetrics","height","forEach","checkAttachedNote","getGlyphProps","getWidth","lines","stemHeight","stem","getStem","abs","getHeight","STAVE_LINE_DISTANCE","stave","getStave","getNumLines","getPosition","noteLine","getLineNumber","increment","top_text_line","curTop","between_lines","setTextLine","text_line","curBottom","width","map","reduce","maxWidth","articWidth","overlap","left_shift","right_shift","easyScoreHook","builder","articNameToCode","staccato","tenuto","accent","split","articString","trim","name","artic","type","PositionString","getFactory","addModifier","constructor","render_options","font_scale","NOTATION_FONT_SCALE","reset","articulationCodes","code","endsWith","aboveCode","belowCode","setWidth","setBetweenLines","betweenLines","draw","ctx","checkContext","setRendered","index","checkIndex","staffSpace","getSpacingBetweenLines","isTab","x","getModifierStartXY","shouldSitOutsideStaff","initialOffset","padding","currentMusicFont","lookupMetric","getCode","y","setOrigin","INITIAL_OFFSET","getKeyProps","distanceFromNote","articLine","Number","render"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/articulation.js"],"sourcesContent":["import { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Stem } from './stem.js';\nimport { Tables } from './tables.js';\nimport { isGraceNote, isStaveNote, isStemmableNote, isTabNote } from './typeguard.js';\nimport { defined, log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (Articulation.DEBUG)\n        log('Vex.Flow.Articulation', args);\n}\nconst { ABOVE, BELOW } = Modifier.Position;\nfunction roundToNearestHalf(mathFn, value) {\n    return mathFn(value / 0.5) * 0.5;\n}\nfunction isWithinLines(line, position) {\n    return position === ABOVE ? line <= 5 : line >= 1;\n}\nfunction getRoundingFunction(line, position) {\n    if (isWithinLines(line, position)) {\n        if (position === ABOVE) {\n            return Math.ceil;\n        }\n        else {\n            return Math.floor;\n        }\n    }\n    else {\n        return Math.round;\n    }\n}\nfunction snapLineToStaff(canSitBetweenLines, line, position, offsetDirection) {\n    const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n    const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n    const onStaffLine = snappedLine % 1 === 0;\n    if (canSnapToStaffSpace && onStaffLine) {\n        const HALF_STAFF_SPACE = 0.5;\n        return snappedLine + HALF_STAFF_SPACE * -offsetDirection;\n    }\n    else {\n        return snappedLine;\n    }\n}\nconst isStaveOrGraceNote = (note) => isStaveNote(note) || isGraceNote(note);\nfunction getTopY(note, textLine) {\n    const stemDirection = note.getStemDirection();\n    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemTipY;\n            }\n            else {\n                return stemBaseY;\n            }\n        }\n        else {\n            return Math.min(...note.getYs());\n        }\n    }\n    else if (isTabNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemTipY;\n            }\n            else {\n                return note.checkStave().getYForTopText(textLine);\n            }\n        }\n        else {\n            return note.checkStave().getYForTopText(textLine);\n        }\n    }\n    else {\n        throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n    }\n}\nfunction getBottomY(note, textLine) {\n    const stemDirection = note.getStemDirection();\n    const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return stemBaseY;\n            }\n            else {\n                return stemTipY;\n            }\n        }\n        else {\n            return Math.max(...note.getYs());\n        }\n    }\n    else if (isTabNote(note)) {\n        if (note.hasStem()) {\n            if (stemDirection === Stem.UP) {\n                return note.checkStave().getYForBottomText(textLine);\n            }\n            else {\n                return stemTipY;\n            }\n        }\n        else {\n            return note.checkStave().getYForBottomText(textLine);\n        }\n    }\n    else {\n        throw new RuntimeError('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n    }\n}\nfunction getInitialOffset(note, position) {\n    const isOnStemTip = (position === ABOVE && note.getStemDirection() === Stem.UP) ||\n        (position === BELOW && note.getStemDirection() === Stem.DOWN);\n    if (isStaveOrGraceNote(note)) {\n        if (note.hasStem() && isOnStemTip) {\n            return 0.5;\n        }\n        else {\n            return 1;\n        }\n    }\n    else {\n        if (note.hasStem() && isOnStemTip) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nclass Articulation extends Modifier {\n    static get CATEGORY() {\n        return \"Articulation\";\n    }\n    static format(articulations, state) {\n        if (!articulations || articulations.length === 0)\n            return false;\n        const margin = 0.5;\n        let maxGlyphWidth = 0;\n        const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), defined(articulation.glyph.getMetrics().height) / 10 + margin);\n        articulations.forEach((articulation) => {\n            const note = articulation.checkAttachedNote();\n            maxGlyphWidth = Math.max(note.getGlyphProps().getWidth(), maxGlyphWidth);\n            let lines = 5;\n            const stemDirection = note.hasStem() ? note.getStemDirection() : Stem.UP;\n            let stemHeight = 0;\n            if (isStemmableNote(note)) {\n                const stem = note.getStem();\n                if (stem) {\n                    stemHeight = Math.abs(stem.getHeight()) / Tables.STAVE_LINE_DISTANCE;\n                }\n            }\n            const stave = note.getStave();\n            if (stave) {\n                lines = stave.getNumLines();\n            }\n            if (articulation.getPosition() === ABOVE) {\n                let noteLine = note.getLineNumber(true);\n                if (stemDirection === Stem.UP) {\n                    noteLine += stemHeight;\n                }\n                let increment = getIncrement(articulation, state.top_text_line, ABOVE);\n                const curTop = noteLine + state.top_text_line + 0.5;\n                if (!articulation.articulation.between_lines && curTop < lines) {\n                    increment += lines - curTop;\n                }\n                articulation.setTextLine(state.top_text_line);\n                state.top_text_line += increment;\n            }\n            else if (articulation.getPosition() === BELOW) {\n                let noteLine = Math.max(lines - note.getLineNumber(), 0);\n                if (stemDirection === Stem.DOWN) {\n                    noteLine += stemHeight;\n                }\n                let increment = getIncrement(articulation, state.text_line, BELOW);\n                const curBottom = noteLine + state.text_line + 0.5;\n                if (!articulation.articulation.between_lines && curBottom < lines) {\n                    increment += lines - curBottom;\n                }\n                articulation.setTextLine(state.text_line);\n                state.text_line += increment;\n            }\n        });\n        const width = articulations\n            .map((articulation) => articulation.getWidth())\n            .reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n        const overlap = Math.min(Math.max(width - maxGlyphWidth, 0), Math.max(width - (state.left_shift + state.right_shift), 0));\n        state.left_shift += overlap / 2;\n        state.right_shift += overlap / 2;\n        return true;\n    }\n    static easyScoreHook({ articulations }, note, builder) {\n        if (!articulations)\n            return;\n        const articNameToCode = {\n            staccato: 'a.',\n            tenuto: 'a-',\n            accent: 'a>',\n        };\n        articulations\n            .split(',')\n            .map((articString) => articString.trim().split('.'))\n            .map(([name, position]) => {\n            const artic = { type: articNameToCode[name] };\n            if (position)\n                artic.position = Modifier.PositionString[position];\n            return builder.getFactory().Articulation(artic);\n        })\n            .map((artic) => note.addModifier(artic, 0));\n    }\n    constructor(type) {\n        super();\n        this.type = type;\n        this.position = ABOVE;\n        this.render_options = {\n            font_scale: Tables.NOTATION_FONT_SCALE,\n        };\n        this.reset();\n    }\n    reset() {\n        this.articulation = Tables.articulationCodes(this.type);\n        if (!this.articulation) {\n            this.articulation = { code: this.type, between_lines: false };\n            if (this.type.endsWith('Above'))\n                this.position = ABOVE;\n            if (this.type.endsWith('Below'))\n                this.position = BELOW;\n        }\n        const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n        this.glyph = new Glyph(code !== null && code !== void 0 ? code : '', this.render_options.font_scale);\n        defined(this.glyph, 'ArgumentError', `Articulation not found: ${this.type}`);\n        this.setWidth(defined(this.glyph.getMetrics().width));\n    }\n    setBetweenLines(betweenLines = true) {\n        this.articulation.between_lines = betweenLines;\n        return this;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const index = this.checkIndex();\n        const { position, glyph, text_line: textLine } = this;\n        const canSitBetweenLines = this.articulation.between_lines;\n        const stave = note.checkStave();\n        const staffSpace = stave.getSpacingBetweenLines();\n        const isTab = isTabNote(note);\n        const { x } = note.getModifierStartXY(position, index);\n        const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n        const initialOffset = getInitialOffset(note, position);\n        const padding = Tables.currentMusicFont().lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n        let y = {\n            [ABOVE]: () => {\n                glyph.setOrigin(0.5, 1);\n                const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;\n                return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;\n            },\n            [BELOW]: () => {\n                glyph.setOrigin(0.5, 0);\n                const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;\n                return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;\n            },\n        }[position]();\n        if (!isTab) {\n            const offsetDirection = position === ABOVE ? -1 : +1;\n            const noteLine = note.getKeyProps()[index].line;\n            const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n            const articLine = distanceFromNote + Number(noteLine);\n            const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n            if (isWithinLines(snappedLine, position))\n                glyph.setOrigin(0.5, 0.5);\n            y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + padding * offsetDirection;\n        }\n        L(`Rendering articulation at (x: ${x}, y: ${y})`);\n        glyph.render(ctx, x, y);\n    }\n}\nArticulation.DEBUG = false;\nArticulation.INITIAL_OFFSET = -0.5;\nexport { Articulation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}