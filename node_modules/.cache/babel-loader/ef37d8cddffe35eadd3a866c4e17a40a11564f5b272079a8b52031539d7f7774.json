{"ast":null,"code":"import { Font } from './font.js';\nimport { drawDot } from './rendercontext.js';\nimport { Tables } from './tables.js';\nimport { Tickable } from './tickable.js';\nimport { defined, RuntimeError } from './util.js';\nexport class Note extends Tickable {\n  static get CATEGORY() {\n    return \"Note\";\n  }\n  static plotMetrics(ctx, note, yPos) {\n    const metrics = note.getMetrics();\n    const xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.leftDisplacedHeadPx;\n    const xPre1 = note.getAbsoluteX() - metrics.leftDisplacedHeadPx;\n    const xAbs = note.getAbsoluteX();\n    const xPost1 = note.getAbsoluteX() + metrics.notePx;\n    const xPost2 = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx;\n    const xEnd = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx + metrics.modRightPx;\n    const xFreedomRight = xEnd + (note.getFormatterMetrics().freedom.right || 0);\n    const xWidth = xEnd - xStart;\n    ctx.save();\n    ctx.setFont(Font.SANS_SERIF, 8);\n    ctx.fillText(Math.round(xWidth) + 'px', xStart + note.getXShift(), yPos);\n    const y = yPos + 7;\n    function stroke(x1, x2, color, yy = y) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(3);\n      ctx.moveTo(x1 + note.getXShift(), yy);\n      ctx.lineTo(x2 + note.getXShift(), yy);\n      ctx.stroke();\n    }\n    stroke(xStart, xPre1, 'red');\n    stroke(xPre1, xAbs, '#999');\n    stroke(xAbs, xPost1, 'green');\n    stroke(xPost1, xPost2, '#999');\n    stroke(xPost2, xEnd, 'red');\n    stroke(xEnd, xFreedomRight, '#DD0');\n    stroke(xStart - note.getXShift(), xStart, '#BBB');\n    drawDot(ctx, xAbs + note.getXShift(), y, 'blue');\n    const formatterMetrics = note.getFormatterMetrics();\n    if (formatterMetrics.iterations > 0) {\n      const spaceDeviation = formatterMetrics.space.deviation;\n      const prefix = spaceDeviation >= 0 ? '+' : '';\n      ctx.setFillStyle('red');\n      ctx.fillText(prefix + Math.round(spaceDeviation), xAbs + note.getXShift(), yPos - 10);\n    }\n    ctx.restore();\n  }\n  static parseDuration(durationString) {\n    if (!durationString) {\n      return undefined;\n    }\n    const regexp = /(\\d*\\/?\\d+|[a-z])(d*)([nrhms]|$)/;\n    const result = regexp.exec(durationString);\n    if (!result) {\n      return undefined;\n    }\n    const duration = result[1];\n    const dots = result[2].length;\n    const type = result[3] || 'n';\n    return {\n      duration,\n      dots,\n      type\n    };\n  }\n  static parseNoteStruct(noteStruct) {\n    const durationProps = Note.parseDuration(noteStruct.duration);\n    if (!durationProps) {\n      return undefined;\n    }\n    let type = noteStruct.type;\n    if (type && !Tables.validTypes[type]) {\n      return undefined;\n    }\n    const customTypes = [];\n    if (!type) {\n      type = durationProps.type || 'n';\n      if (noteStruct.keys !== undefined) {\n        noteStruct.keys.forEach((k, i) => {\n          const result = k.split('/');\n          customTypes[i] = result && result.length === 3 ? result[2] : type;\n        });\n      }\n    }\n    let ticks = Tables.durationToTicks(durationProps.duration);\n    if (!ticks) {\n      return undefined;\n    }\n    const dots = noteStruct.dots ? noteStruct.dots : durationProps.dots;\n    if (typeof dots !== 'number') {\n      return undefined;\n    }\n    let currentTicks = ticks;\n    for (let i = 0; i < dots; i++) {\n      if (currentTicks <= 1) return undefined;\n      currentTicks = currentTicks / 2;\n      ticks += currentTicks;\n    }\n    return {\n      duration: durationProps.duration,\n      type,\n      customTypes,\n      dots,\n      ticks\n    };\n  }\n  constructor(noteStruct) {\n    super();\n    if (!noteStruct) {\n      throw new RuntimeError('BadArguments', 'Note must have valid initialization data to identify duration and type.');\n    }\n    const parsedNoteStruct = Note.parseNoteStruct(noteStruct);\n    if (!parsedNoteStruct) {\n      throw new RuntimeError('BadArguments', `Invalid note initialization object: ${JSON.stringify(noteStruct)}`);\n    }\n    this.keys = noteStruct.keys || [];\n    this.keyProps = [];\n    this.duration = parsedNoteStruct.duration;\n    this.noteType = parsedNoteStruct.type;\n    this.customTypes = parsedNoteStruct.customTypes;\n    if (noteStruct.duration_override) {\n      this.setDuration(noteStruct.duration_override);\n    } else {\n      this.setIntrinsicTicks(parsedNoteStruct.ticks);\n    }\n    this.modifiers = [];\n    this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n    this.customGlyphs = this.customTypes.map(t => Tables.getGlyphProps(this.duration, t));\n    this.playNote = undefined;\n    this.ignore_ticks = false;\n    this.width = 0;\n    this.leftDisplacedHeadPx = 0;\n    this.rightDisplacedHeadPx = 0;\n    this.x_shift = 0;\n    this.ys = [];\n    if (noteStruct.align_center) {\n      this.setCenterAlignment(noteStruct.align_center);\n    }\n    this.render_options = {\n      annotation_spacing: 5,\n      glyph_font_scale: 1,\n      stroke_px: 1,\n      scale: 1,\n      font: '',\n      y_shift: 0\n    };\n  }\n  getPlayNote() {\n    return this.playNote;\n  }\n  setPlayNote(note) {\n    this.playNote = note;\n    return this;\n  }\n  isRest() {\n    return false;\n  }\n  addStroke(index, stroke) {\n    stroke.setNote(this);\n    stroke.setIndex(index);\n    this.modifiers.push(stroke);\n    this.preFormatted = false;\n    return this;\n  }\n  getStave() {\n    return this.stave;\n  }\n  checkStave() {\n    return defined(this.stave, 'NoStave', 'No stave attached to instance.');\n  }\n  setStave(stave) {\n    this.stave = stave;\n    this.setYs([stave.getYForLine(0)]);\n    this.setContext(this.stave.getContext());\n    return this;\n  }\n  getLeftDisplacedHeadPx() {\n    return this.leftDisplacedHeadPx;\n  }\n  getRightDisplacedHeadPx() {\n    return this.rightDisplacedHeadPx;\n  }\n  setLeftDisplacedHeadPx(x) {\n    this.leftDisplacedHeadPx = x;\n    return this;\n  }\n  setRightDisplacedHeadPx(x) {\n    this.rightDisplacedHeadPx = x;\n    return this;\n  }\n  shouldIgnoreTicks() {\n    return this.ignore_ticks;\n  }\n  getLineNumber(isTopNote) {\n    return 0;\n  }\n  getLineForRest() {\n    return 0;\n  }\n  getGlyph() {\n    return this.glyphProps;\n  }\n  getGlyphProps() {\n    return this.glyphProps;\n  }\n  getGlyphWidth() {\n    return this.glyphProps.getWidth(this.render_options.glyph_font_scale);\n  }\n  setYs(ys) {\n    this.ys = ys;\n    return this;\n  }\n  getYs() {\n    if (this.ys.length === 0) {\n      throw new RuntimeError('NoYValues', 'No Y-values calculated for this note.');\n    }\n    return this.ys;\n  }\n  getYForTopText(text_line) {\n    return this.checkStave().getYForTopText(text_line);\n  }\n  getVoice() {\n    if (!this.voice) throw new RuntimeError('NoVoice', 'Note has no voice.');\n    return this.voice;\n  }\n  setVoice(voice) {\n    this.voice = voice;\n    this.preFormatted = false;\n    return this;\n  }\n  getTickContext() {\n    return this.checkTickContext();\n  }\n  setTickContext(tc) {\n    this.tickContext = tc;\n    this.preFormatted = false;\n    return this;\n  }\n  getDuration() {\n    return this.duration;\n  }\n  isDotted() {\n    return this.getModifiersByType(\"Dot\").length > 0;\n  }\n  hasStem() {\n    return false;\n  }\n  getNoteType() {\n    return this.noteType;\n  }\n  getBeam() {\n    return this.beam;\n  }\n  checkBeam() {\n    return defined(this.beam, 'NoBeam', 'No beam attached to instance');\n  }\n  hasBeam() {\n    return this.beam != undefined;\n  }\n  setBeam(beam) {\n    this.beam = beam;\n    return this;\n  }\n  addModifier(modifier, index = 0) {\n    const signature = 'Note.addModifier(modifier: Modifier, index: number=0)';\n    if (typeof index === 'string') {\n      index = parseInt(index);\n      console.warn(signature + ' expected a number for `index`, but received a string.');\n    }\n    if (typeof modifier !== 'object' || typeof index !== 'number') {\n      throw new RuntimeError('WrongParams', 'Incorrect call signature. Use ' + signature + ' instead.');\n    }\n    modifier.setNote(this);\n    modifier.setIndex(index);\n    super.addModifier(modifier);\n    return this;\n  }\n  getModifiersByType(type) {\n    return this.modifiers.filter(modifier => modifier.getCategory() === type);\n  }\n  getModifierStartXY(position, index, options) {\n    if (!this.preFormatted) {\n      throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n    return {\n      x: this.getAbsoluteX(),\n      y: this.ys[0]\n    };\n  }\n  getRightParenthesisPx(index) {\n    const props = this.getKeyProps()[index];\n    return props.displaced ? this.getRightDisplacedHeadPx() : 0;\n  }\n  getLeftParenthesisPx(index) {\n    const props = this.getKeyProps()[index];\n    return props.displaced ? this.getLeftDisplacedHeadPx() - this.x_shift : -this.x_shift;\n  }\n  getFirstDotPx() {\n    let px = this.getRightDisplacedHeadPx();\n    if (this.checkModifierContext().getMembers('Parenthesis').length !== 0) px += Tables.currentMusicFont().lookupMetric('parenthesis.default.width');\n    return px;\n  }\n  getMetrics() {\n    if (!this.preFormatted) {\n      throw new RuntimeError('UnformattedNote', \"Can't call getMetrics on an unformatted note.\");\n    }\n    const modLeftPx = this.modifierContext ? this.modifierContext.getState().left_shift : 0;\n    const modRightPx = this.modifierContext ? this.modifierContext.getState().right_shift : 0;\n    const width = this.getWidth();\n    const glyphWidth = this.getGlyphWidth();\n    const notePx = width - modLeftPx - modRightPx - this.leftDisplacedHeadPx - this.rightDisplacedHeadPx;\n    return {\n      width,\n      glyphWidth,\n      notePx,\n      modLeftPx,\n      modRightPx,\n      leftDisplacedHeadPx: this.leftDisplacedHeadPx,\n      rightDisplacedHeadPx: this.rightDisplacedHeadPx,\n      glyphPx: 0\n    };\n  }\n  getAbsoluteX() {\n    const tickContext = this.checkTickContext(`Can't getAbsoluteX() without a TickContext.`);\n    let x = tickContext.getX();\n    if (this.stave) {\n      x += this.stave.getNoteStartX() + Tables.currentMusicFont().lookupMetric('stave.padding');\n    }\n    if (this.isCenterAligned()) {\n      x += this.getCenterXShift();\n    }\n    return x;\n  }\n  static getPoint(size) {\n    return size == 'default' ? Tables.NOTATION_FONT_SCALE : Tables.NOTATION_FONT_SCALE / 5 * 3;\n  }\n  getStemDirection() {\n    throw new RuntimeError('NoStem', 'No stem attached to this note.');\n  }\n  getStemExtents() {\n    throw new RuntimeError('NoStem', 'No stem attached to this note.');\n  }\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    const note_glyph_width = this.glyphProps.getWidth();\n    tieStartX += note_glyph_width / 2;\n    tieStartX += -this.width / 2 + this.width + 2;\n    return tieStartX;\n  }\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    const note_glyph_width = this.glyphProps.getWidth();\n    tieEndX += note_glyph_width / 2;\n    tieEndX -= this.width / 2 + 2;\n    return tieEndX;\n  }\n  getKeys() {\n    return this.keys;\n  }\n  getKeyProps() {\n    return this.keyProps;\n  }\n}","map":{"version":3,"names":["Font","drawDot","Tables","Tickable","defined","RuntimeError","Note","CATEGORY","plotMetrics","ctx","note","yPos","metrics","getMetrics","xStart","getAbsoluteX","modLeftPx","leftDisplacedHeadPx","xPre1","xAbs","xPost1","notePx","xPost2","rightDisplacedHeadPx","xEnd","modRightPx","xFreedomRight","getFormatterMetrics","freedom","right","xWidth","save","setFont","SANS_SERIF","fillText","Math","round","getXShift","y","stroke","x1","x2","color","yy","beginPath","setStrokeStyle","setFillStyle","setLineWidth","moveTo","lineTo","formatterMetrics","iterations","spaceDeviation","space","deviation","prefix","restore","parseDuration","durationString","undefined","regexp","result","exec","duration","dots","length","type","parseNoteStruct","noteStruct","durationProps","validTypes","customTypes","keys","forEach","k","i","split","ticks","durationToTicks","currentTicks","constructor","parsedNoteStruct","JSON","stringify","keyProps","noteType","duration_override","setDuration","setIntrinsicTicks","modifiers","glyphProps","getGlyphProps","customGlyphs","map","t","playNote","ignore_ticks","width","x_shift","ys","align_center","setCenterAlignment","render_options","annotation_spacing","glyph_font_scale","stroke_px","scale","font","y_shift","getPlayNote","setPlayNote","isRest","addStroke","index","setNote","setIndex","push","preFormatted","getStave","stave","checkStave","setStave","setYs","getYForLine","setContext","getContext","getLeftDisplacedHeadPx","getRightDisplacedHeadPx","setLeftDisplacedHeadPx","x","setRightDisplacedHeadPx","shouldIgnoreTicks","getLineNumber","isTopNote","getLineForRest","getGlyph","getGlyphWidth","getWidth","getYs","getYForTopText","text_line","getVoice","voice","setVoice","getTickContext","checkTickContext","setTickContext","tc","tickContext","getDuration","isDotted","getModifiersByType","hasStem","getNoteType","getBeam","beam","checkBeam","hasBeam","setBeam","addModifier","modifier","signature","parseInt","console","warn","filter","getCategory","getModifierStartXY","position","options","getRightParenthesisPx","props","getKeyProps","displaced","getLeftParenthesisPx","getFirstDotPx","px","checkModifierContext","getMembers","currentMusicFont","lookupMetric","modifierContext","getState","left_shift","right_shift","glyphWidth","glyphPx","getX","getNoteStartX","isCenterAligned","getCenterXShift","getPoint","size","NOTATION_FONT_SCALE","getStemDirection","getStemExtents","getTieRightX","tieStartX","note_glyph_width","getTieLeftX","tieEndX","getKeys"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/note.js"],"sourcesContent":["import { Font } from './font.js';\nimport { drawDot } from './rendercontext.js';\nimport { Tables } from './tables.js';\nimport { Tickable } from './tickable.js';\nimport { defined, RuntimeError } from './util.js';\nexport class Note extends Tickable {\n    static get CATEGORY() {\n        return \"Note\";\n    }\n    static plotMetrics(ctx, note, yPos) {\n        const metrics = note.getMetrics();\n        const xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.leftDisplacedHeadPx;\n        const xPre1 = note.getAbsoluteX() - metrics.leftDisplacedHeadPx;\n        const xAbs = note.getAbsoluteX();\n        const xPost1 = note.getAbsoluteX() + metrics.notePx;\n        const xPost2 = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx;\n        const xEnd = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx + metrics.modRightPx;\n        const xFreedomRight = xEnd + (note.getFormatterMetrics().freedom.right || 0);\n        const xWidth = xEnd - xStart;\n        ctx.save();\n        ctx.setFont(Font.SANS_SERIF, 8);\n        ctx.fillText(Math.round(xWidth) + 'px', xStart + note.getXShift(), yPos);\n        const y = yPos + 7;\n        function stroke(x1, x2, color, yy = y) {\n            ctx.beginPath();\n            ctx.setStrokeStyle(color);\n            ctx.setFillStyle(color);\n            ctx.setLineWidth(3);\n            ctx.moveTo(x1 + note.getXShift(), yy);\n            ctx.lineTo(x2 + note.getXShift(), yy);\n            ctx.stroke();\n        }\n        stroke(xStart, xPre1, 'red');\n        stroke(xPre1, xAbs, '#999');\n        stroke(xAbs, xPost1, 'green');\n        stroke(xPost1, xPost2, '#999');\n        stroke(xPost2, xEnd, 'red');\n        stroke(xEnd, xFreedomRight, '#DD0');\n        stroke(xStart - note.getXShift(), xStart, '#BBB');\n        drawDot(ctx, xAbs + note.getXShift(), y, 'blue');\n        const formatterMetrics = note.getFormatterMetrics();\n        if (formatterMetrics.iterations > 0) {\n            const spaceDeviation = formatterMetrics.space.deviation;\n            const prefix = spaceDeviation >= 0 ? '+' : '';\n            ctx.setFillStyle('red');\n            ctx.fillText(prefix + Math.round(spaceDeviation), xAbs + note.getXShift(), yPos - 10);\n        }\n        ctx.restore();\n    }\n    static parseDuration(durationString) {\n        if (!durationString) {\n            return undefined;\n        }\n        const regexp = /(\\d*\\/?\\d+|[a-z])(d*)([nrhms]|$)/;\n        const result = regexp.exec(durationString);\n        if (!result) {\n            return undefined;\n        }\n        const duration = result[1];\n        const dots = result[2].length;\n        const type = result[3] || 'n';\n        return { duration, dots, type };\n    }\n    static parseNoteStruct(noteStruct) {\n        const durationProps = Note.parseDuration(noteStruct.duration);\n        if (!durationProps) {\n            return undefined;\n        }\n        let type = noteStruct.type;\n        if (type && !Tables.validTypes[type]) {\n            return undefined;\n        }\n        const customTypes = [];\n        if (!type) {\n            type = durationProps.type || 'n';\n            if (noteStruct.keys !== undefined) {\n                noteStruct.keys.forEach((k, i) => {\n                    const result = k.split('/');\n                    customTypes[i] = (result && result.length === 3 ? result[2] : type);\n                });\n            }\n        }\n        let ticks = Tables.durationToTicks(durationProps.duration);\n        if (!ticks) {\n            return undefined;\n        }\n        const dots = noteStruct.dots ? noteStruct.dots : durationProps.dots;\n        if (typeof dots !== 'number') {\n            return undefined;\n        }\n        let currentTicks = ticks;\n        for (let i = 0; i < dots; i++) {\n            if (currentTicks <= 1)\n                return undefined;\n            currentTicks = currentTicks / 2;\n            ticks += currentTicks;\n        }\n        return {\n            duration: durationProps.duration,\n            type,\n            customTypes,\n            dots,\n            ticks,\n        };\n    }\n    constructor(noteStruct) {\n        super();\n        if (!noteStruct) {\n            throw new RuntimeError('BadArguments', 'Note must have valid initialization data to identify duration and type.');\n        }\n        const parsedNoteStruct = Note.parseNoteStruct(noteStruct);\n        if (!parsedNoteStruct) {\n            throw new RuntimeError('BadArguments', `Invalid note initialization object: ${JSON.stringify(noteStruct)}`);\n        }\n        this.keys = noteStruct.keys || [];\n        this.keyProps = [];\n        this.duration = parsedNoteStruct.duration;\n        this.noteType = parsedNoteStruct.type;\n        this.customTypes = parsedNoteStruct.customTypes;\n        if (noteStruct.duration_override) {\n            this.setDuration(noteStruct.duration_override);\n        }\n        else {\n            this.setIntrinsicTicks(parsedNoteStruct.ticks);\n        }\n        this.modifiers = [];\n        this.glyphProps = Tables.getGlyphProps(this.duration, this.noteType);\n        this.customGlyphs = this.customTypes.map((t) => Tables.getGlyphProps(this.duration, t));\n        this.playNote = undefined;\n        this.ignore_ticks = false;\n        this.width = 0;\n        this.leftDisplacedHeadPx = 0;\n        this.rightDisplacedHeadPx = 0;\n        this.x_shift = 0;\n        this.ys = [];\n        if (noteStruct.align_center) {\n            this.setCenterAlignment(noteStruct.align_center);\n        }\n        this.render_options = {\n            annotation_spacing: 5,\n            glyph_font_scale: 1,\n            stroke_px: 1,\n            scale: 1,\n            font: '',\n            y_shift: 0,\n        };\n    }\n    getPlayNote() {\n        return this.playNote;\n    }\n    setPlayNote(note) {\n        this.playNote = note;\n        return this;\n    }\n    isRest() {\n        return false;\n    }\n    addStroke(index, stroke) {\n        stroke.setNote(this);\n        stroke.setIndex(index);\n        this.modifiers.push(stroke);\n        this.preFormatted = false;\n        return this;\n    }\n    getStave() {\n        return this.stave;\n    }\n    checkStave() {\n        return defined(this.stave, 'NoStave', 'No stave attached to instance.');\n    }\n    setStave(stave) {\n        this.stave = stave;\n        this.setYs([stave.getYForLine(0)]);\n        this.setContext(this.stave.getContext());\n        return this;\n    }\n    getLeftDisplacedHeadPx() {\n        return this.leftDisplacedHeadPx;\n    }\n    getRightDisplacedHeadPx() {\n        return this.rightDisplacedHeadPx;\n    }\n    setLeftDisplacedHeadPx(x) {\n        this.leftDisplacedHeadPx = x;\n        return this;\n    }\n    setRightDisplacedHeadPx(x) {\n        this.rightDisplacedHeadPx = x;\n        return this;\n    }\n    shouldIgnoreTicks() {\n        return this.ignore_ticks;\n    }\n    getLineNumber(isTopNote) {\n        return 0;\n    }\n    getLineForRest() {\n        return 0;\n    }\n    getGlyph() {\n        return this.glyphProps;\n    }\n    getGlyphProps() {\n        return this.glyphProps;\n    }\n    getGlyphWidth() {\n        return this.glyphProps.getWidth(this.render_options.glyph_font_scale);\n    }\n    setYs(ys) {\n        this.ys = ys;\n        return this;\n    }\n    getYs() {\n        if (this.ys.length === 0) {\n            throw new RuntimeError('NoYValues', 'No Y-values calculated for this note.');\n        }\n        return this.ys;\n    }\n    getYForTopText(text_line) {\n        return this.checkStave().getYForTopText(text_line);\n    }\n    getVoice() {\n        if (!this.voice)\n            throw new RuntimeError('NoVoice', 'Note has no voice.');\n        return this.voice;\n    }\n    setVoice(voice) {\n        this.voice = voice;\n        this.preFormatted = false;\n        return this;\n    }\n    getTickContext() {\n        return this.checkTickContext();\n    }\n    setTickContext(tc) {\n        this.tickContext = tc;\n        this.preFormatted = false;\n        return this;\n    }\n    getDuration() {\n        return this.duration;\n    }\n    isDotted() {\n        return this.getModifiersByType(\"Dot\").length > 0;\n    }\n    hasStem() {\n        return false;\n    }\n    getNoteType() {\n        return this.noteType;\n    }\n    getBeam() {\n        return this.beam;\n    }\n    checkBeam() {\n        return defined(this.beam, 'NoBeam', 'No beam attached to instance');\n    }\n    hasBeam() {\n        return this.beam != undefined;\n    }\n    setBeam(beam) {\n        this.beam = beam;\n        return this;\n    }\n    addModifier(modifier, index = 0) {\n        const signature = 'Note.addModifier(modifier: Modifier, index: number=0)';\n        if (typeof index === 'string') {\n            index = parseInt(index);\n            console.warn(signature + ' expected a number for `index`, but received a string.');\n        }\n        if (typeof modifier !== 'object' || typeof index !== 'number') {\n            throw new RuntimeError('WrongParams', 'Incorrect call signature. Use ' + signature + ' instead.');\n        }\n        modifier.setNote(this);\n        modifier.setIndex(index);\n        super.addModifier(modifier);\n        return this;\n    }\n    getModifiersByType(type) {\n        return this.modifiers.filter((modifier) => modifier.getCategory() === type);\n    }\n    getModifierStartXY(position, index, options) {\n        if (!this.preFormatted) {\n            throw new RuntimeError('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n        }\n        return {\n            x: this.getAbsoluteX(),\n            y: this.ys[0],\n        };\n    }\n    getRightParenthesisPx(index) {\n        const props = this.getKeyProps()[index];\n        return props.displaced ? this.getRightDisplacedHeadPx() : 0;\n    }\n    getLeftParenthesisPx(index) {\n        const props = this.getKeyProps()[index];\n        return props.displaced ? this.getLeftDisplacedHeadPx() - this.x_shift : -this.x_shift;\n    }\n    getFirstDotPx() {\n        let px = this.getRightDisplacedHeadPx();\n        if (this.checkModifierContext().getMembers('Parenthesis').length !== 0)\n            px += Tables.currentMusicFont().lookupMetric('parenthesis.default.width');\n        return px;\n    }\n    getMetrics() {\n        if (!this.preFormatted) {\n            throw new RuntimeError('UnformattedNote', \"Can't call getMetrics on an unformatted note.\");\n        }\n        const modLeftPx = this.modifierContext ? this.modifierContext.getState().left_shift : 0;\n        const modRightPx = this.modifierContext ? this.modifierContext.getState().right_shift : 0;\n        const width = this.getWidth();\n        const glyphWidth = this.getGlyphWidth();\n        const notePx = width -\n            modLeftPx -\n            modRightPx -\n            this.leftDisplacedHeadPx -\n            this.rightDisplacedHeadPx;\n        return {\n            width,\n            glyphWidth,\n            notePx,\n            modLeftPx,\n            modRightPx,\n            leftDisplacedHeadPx: this.leftDisplacedHeadPx,\n            rightDisplacedHeadPx: this.rightDisplacedHeadPx,\n            glyphPx: 0,\n        };\n    }\n    getAbsoluteX() {\n        const tickContext = this.checkTickContext(`Can't getAbsoluteX() without a TickContext.`);\n        let x = tickContext.getX();\n        if (this.stave) {\n            x += this.stave.getNoteStartX() + Tables.currentMusicFont().lookupMetric('stave.padding');\n        }\n        if (this.isCenterAligned()) {\n            x += this.getCenterXShift();\n        }\n        return x;\n    }\n    static getPoint(size) {\n        return size == 'default' ? Tables.NOTATION_FONT_SCALE : (Tables.NOTATION_FONT_SCALE / 5) * 3;\n    }\n    getStemDirection() {\n        throw new RuntimeError('NoStem', 'No stem attached to this note.');\n    }\n    getStemExtents() {\n        throw new RuntimeError('NoStem', 'No stem attached to this note.');\n    }\n    getTieRightX() {\n        let tieStartX = this.getAbsoluteX();\n        const note_glyph_width = this.glyphProps.getWidth();\n        tieStartX += note_glyph_width / 2;\n        tieStartX += -this.width / 2 + this.width + 2;\n        return tieStartX;\n    }\n    getTieLeftX() {\n        let tieEndX = this.getAbsoluteX();\n        const note_glyph_width = this.glyphProps.getWidth();\n        tieEndX += note_glyph_width / 2;\n        tieEndX -= this.width / 2 + 2;\n        return tieEndX;\n    }\n    getKeys() {\n        return this.keys;\n    }\n    getKeyProps() {\n        return this.keyProps;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}