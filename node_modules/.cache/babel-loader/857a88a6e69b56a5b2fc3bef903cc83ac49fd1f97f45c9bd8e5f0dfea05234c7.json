{"ast":null,"code":"import { Element } from './element.js';\nimport { Modifier } from './modifier.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nclass Bend extends Modifier {\n  static get CATEGORY() {\n    return \"Bend\";\n  }\n  static get UP() {\n    return 0;\n  }\n  static get DOWN() {\n    return 1;\n  }\n  static format(bends, state) {\n    if (!bends || bends.length === 0) return false;\n    let last_width = 0;\n    for (let i = 0; i < bends.length; ++i) {\n      const bend = bends[i];\n      const note = bend.checkAttachedNote();\n      if (isTabNote(note)) {\n        const stringPos = note.leastString() - 1;\n        if (state.top_text_line < stringPos) {\n          state.top_text_line = stringPos;\n        }\n      }\n      bend.setXShift(last_width);\n      last_width = bend.getWidth();\n      bend.setTextLine(state.top_text_line);\n    }\n    state.right_shift += last_width;\n    state.top_text_line += 1;\n    return true;\n  }\n  constructor(text, release = false, phrase) {\n    super();\n    this.text = text;\n    this.x_shift = 0;\n    this.release = release;\n    this.tap = '';\n    this.resetFont();\n    this.render_options = {\n      line_width: 1.5,\n      line_style: '#777777',\n      bend_width: 8,\n      release_width: 8\n    };\n    if (phrase) {\n      this.phrase = phrase;\n    } else {\n      this.phrase = [{\n        type: Bend.UP,\n        text: this.text\n      }];\n      if (this.release) this.phrase.push({\n        type: Bend.DOWN,\n        text: ''\n      });\n    }\n    this.updateWidth();\n  }\n  setXShift(value) {\n    this.x_shift = value;\n    this.updateWidth();\n    return this;\n  }\n  setTap(value) {\n    this.tap = value;\n    return this;\n  }\n  getText() {\n    return this.text;\n  }\n  getTextHeight() {\n    const textFormatter = TextFormatter.create(this.textFont);\n    return textFormatter.maxHeight;\n  }\n  updateWidth() {\n    const textFormatter = TextFormatter.create(this.textFont);\n    const measureText = text => {\n      return textFormatter.getWidthForTextInPx(text);\n    };\n    let totalWidth = 0;\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n      if (bend.width !== undefined) {\n        totalWidth += bend.width;\n      } else {\n        const additional_width = bend.type === Bend.UP ? this.render_options.bend_width : this.render_options.release_width;\n        bend.width = Math.max(additional_width, measureText(bend.text)) + 3;\n        bend.draw_width = bend.width / 2;\n        totalWidth += bend.width;\n      }\n    }\n    this.setWidth(totalWidth + this.x_shift);\n    return this;\n  }\n  draw() {\n    var _a;\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    const start = note.getModifierStartXY(Modifier.Position.RIGHT, this.index);\n    start.x += 3;\n    start.y += 0.5;\n    const x_shift = this.x_shift;\n    const stave = note.checkStave();\n    const spacing = stave.getSpacingBetweenLines();\n    const lowestY = note.getYs().reduce((a, b) => a < b ? a : b);\n    const bend_height = start.y - ((this.text_line + 1) * spacing + start.y - lowestY) + 3;\n    const annotation_y = start.y - ((this.text_line + 1) * spacing + start.y - lowestY) - 1;\n    const renderBend = (x, y, width, height) => {\n      const cp_x = x + width;\n      const cp_y = y;\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(this.render_options.line_width);\n      ctx.setStrokeStyle(this.render_options.line_style);\n      ctx.setFillStyle(this.render_options.line_style);\n      ctx.moveTo(x, y);\n      ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);\n      ctx.stroke();\n      ctx.restore();\n    };\n    const renderRelease = (x, y, width, height) => {\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(this.render_options.line_width);\n      ctx.setStrokeStyle(this.render_options.line_style);\n      ctx.setFillStyle(this.render_options.line_style);\n      ctx.moveTo(x, height);\n      ctx.quadraticCurveTo(x + width, height, x + width, y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    const renderArrowHead = (x, y, direction) => {\n      const width = 4;\n      const yBase = y + width * direction;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x - width, yBase);\n      ctx.lineTo(x + width, yBase);\n      ctx.closePath();\n      ctx.fill();\n    };\n    const renderText = (x, text) => {\n      ctx.save();\n      ctx.setFont(this.textFont);\n      const render_x = x - ctx.measureText(text).width / 2;\n      ctx.fillText(text, render_x, annotation_y);\n      ctx.restore();\n    };\n    let last_bend = undefined;\n    let last_bend_draw_width = 0;\n    let last_drawn_width = 0;\n    if ((_a = this.tap) === null || _a === void 0 ? void 0 : _a.length) {\n      const tapStart = note.getModifierStartXY(Modifier.Position.CENTER, this.index);\n      renderText(tapStart.x, this.tap);\n    }\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n      if (!bend.draw_width) bend.draw_width = 0;\n      if (i === 0) bend.draw_width += x_shift;\n      last_drawn_width = bend.draw_width + last_bend_draw_width - (i === 1 ? x_shift : 0);\n      if (bend.type === Bend.UP) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderArrowHead(start.x, bend_height, +1);\n        }\n        renderBend(start.x, start.y, last_drawn_width, bend_height);\n      }\n      if (bend.type === Bend.DOWN) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n        if (last_bend && last_bend.type === Bend.DOWN) {\n          renderArrowHead(start.x, start.y, -1);\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n        if (!last_bend) {\n          last_drawn_width = bend.draw_width;\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n      }\n      renderText(start.x + last_drawn_width, bend.text);\n      last_bend = bend;\n      last_bend_draw_width = bend.draw_width;\n      last_bend.x = start.x;\n      start.x += last_drawn_width;\n    }\n    if (!last_bend || last_bend.x == undefined) {\n      throw new RuntimeError('NoLastBendForBend', 'Internal error.');\n    }\n    if (last_bend.type === Bend.UP) {\n      renderArrowHead(last_bend.x + last_drawn_width, bend_height, +1);\n    } else if (last_bend.type === Bend.DOWN) {\n      renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);\n    }\n  }\n}\nBend.TEXT_FONT = Object.assign({}, Element.TEXT_FONT);\nexport { Bend };","map":{"version":3,"names":["Element","Modifier","TextFormatter","isTabNote","RuntimeError","Bend","CATEGORY","UP","DOWN","format","bends","state","length","last_width","i","bend","note","checkAttachedNote","stringPos","leastString","top_text_line","setXShift","getWidth","setTextLine","right_shift","constructor","text","release","phrase","x_shift","tap","resetFont","render_options","line_width","line_style","bend_width","release_width","type","push","updateWidth","value","setTap","getText","getTextHeight","textFormatter","create","textFont","maxHeight","measureText","getWidthForTextInPx","totalWidth","width","undefined","additional_width","Math","max","draw_width","setWidth","draw","_a","ctx","checkContext","setRendered","start","getModifierStartXY","Position","RIGHT","index","x","y","stave","checkStave","spacing","getSpacingBetweenLines","lowestY","getYs","reduce","a","b","bend_height","text_line","annotation_y","renderBend","height","cp_x","cp_y","save","beginPath","setLineWidth","setStrokeStyle","setFillStyle","moveTo","quadraticCurveTo","stroke","restore","renderRelease","renderArrowHead","direction","yBase","lineTo","closePath","fill","renderText","setFont","render_x","fillText","last_bend","last_bend_draw_width","last_drawn_width","tapStart","CENTER","TEXT_FONT","Object","assign"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/bend.js"],"sourcesContent":["import { Element } from './element.js';\nimport { Modifier } from './modifier.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isTabNote } from './typeguard.js';\nimport { RuntimeError } from './util.js';\nclass Bend extends Modifier {\n    static get CATEGORY() {\n        return \"Bend\";\n    }\n    static get UP() {\n        return 0;\n    }\n    static get DOWN() {\n        return 1;\n    }\n    static format(bends, state) {\n        if (!bends || bends.length === 0)\n            return false;\n        let last_width = 0;\n        for (let i = 0; i < bends.length; ++i) {\n            const bend = bends[i];\n            const note = bend.checkAttachedNote();\n            if (isTabNote(note)) {\n                const stringPos = note.leastString() - 1;\n                if (state.top_text_line < stringPos) {\n                    state.top_text_line = stringPos;\n                }\n            }\n            bend.setXShift(last_width);\n            last_width = bend.getWidth();\n            bend.setTextLine(state.top_text_line);\n        }\n        state.right_shift += last_width;\n        state.top_text_line += 1;\n        return true;\n    }\n    constructor(text, release = false, phrase) {\n        super();\n        this.text = text;\n        this.x_shift = 0;\n        this.release = release;\n        this.tap = '';\n        this.resetFont();\n        this.render_options = {\n            line_width: 1.5,\n            line_style: '#777777',\n            bend_width: 8,\n            release_width: 8,\n        };\n        if (phrase) {\n            this.phrase = phrase;\n        }\n        else {\n            this.phrase = [{ type: Bend.UP, text: this.text }];\n            if (this.release)\n                this.phrase.push({ type: Bend.DOWN, text: '' });\n        }\n        this.updateWidth();\n    }\n    setXShift(value) {\n        this.x_shift = value;\n        this.updateWidth();\n        return this;\n    }\n    setTap(value) {\n        this.tap = value;\n        return this;\n    }\n    getText() {\n        return this.text;\n    }\n    getTextHeight() {\n        const textFormatter = TextFormatter.create(this.textFont);\n        return textFormatter.maxHeight;\n    }\n    updateWidth() {\n        const textFormatter = TextFormatter.create(this.textFont);\n        const measureText = (text) => {\n            return textFormatter.getWidthForTextInPx(text);\n        };\n        let totalWidth = 0;\n        for (let i = 0; i < this.phrase.length; ++i) {\n            const bend = this.phrase[i];\n            if (bend.width !== undefined) {\n                totalWidth += bend.width;\n            }\n            else {\n                const additional_width = bend.type === Bend.UP ? this.render_options.bend_width : this.render_options.release_width;\n                bend.width = Math.max(additional_width, measureText(bend.text)) + 3;\n                bend.draw_width = bend.width / 2;\n                totalWidth += bend.width;\n            }\n        }\n        this.setWidth(totalWidth + this.x_shift);\n        return this;\n    }\n    draw() {\n        var _a;\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        const start = note.getModifierStartXY(Modifier.Position.RIGHT, this.index);\n        start.x += 3;\n        start.y += 0.5;\n        const x_shift = this.x_shift;\n        const stave = note.checkStave();\n        const spacing = stave.getSpacingBetweenLines();\n        const lowestY = note.getYs().reduce((a, b) => (a < b ? a : b));\n        const bend_height = start.y - ((this.text_line + 1) * spacing + start.y - lowestY) + 3;\n        const annotation_y = start.y - ((this.text_line + 1) * spacing + start.y - lowestY) - 1;\n        const renderBend = (x, y, width, height) => {\n            const cp_x = x + width;\n            const cp_y = y;\n            ctx.save();\n            ctx.beginPath();\n            ctx.setLineWidth(this.render_options.line_width);\n            ctx.setStrokeStyle(this.render_options.line_style);\n            ctx.setFillStyle(this.render_options.line_style);\n            ctx.moveTo(x, y);\n            ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);\n            ctx.stroke();\n            ctx.restore();\n        };\n        const renderRelease = (x, y, width, height) => {\n            ctx.save();\n            ctx.beginPath();\n            ctx.setLineWidth(this.render_options.line_width);\n            ctx.setStrokeStyle(this.render_options.line_style);\n            ctx.setFillStyle(this.render_options.line_style);\n            ctx.moveTo(x, height);\n            ctx.quadraticCurveTo(x + width, height, x + width, y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        const renderArrowHead = (x, y, direction) => {\n            const width = 4;\n            const yBase = y + width * direction;\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x - width, yBase);\n            ctx.lineTo(x + width, yBase);\n            ctx.closePath();\n            ctx.fill();\n        };\n        const renderText = (x, text) => {\n            ctx.save();\n            ctx.setFont(this.textFont);\n            const render_x = x - ctx.measureText(text).width / 2;\n            ctx.fillText(text, render_x, annotation_y);\n            ctx.restore();\n        };\n        let last_bend = undefined;\n        let last_bend_draw_width = 0;\n        let last_drawn_width = 0;\n        if ((_a = this.tap) === null || _a === void 0 ? void 0 : _a.length) {\n            const tapStart = note.getModifierStartXY(Modifier.Position.CENTER, this.index);\n            renderText(tapStart.x, this.tap);\n        }\n        for (let i = 0; i < this.phrase.length; ++i) {\n            const bend = this.phrase[i];\n            if (!bend.draw_width)\n                bend.draw_width = 0;\n            if (i === 0)\n                bend.draw_width += x_shift;\n            last_drawn_width = bend.draw_width + last_bend_draw_width - (i === 1 ? x_shift : 0);\n            if (bend.type === Bend.UP) {\n                if (last_bend && last_bend.type === Bend.UP) {\n                    renderArrowHead(start.x, bend_height, +1);\n                }\n                renderBend(start.x, start.y, last_drawn_width, bend_height);\n            }\n            if (bend.type === Bend.DOWN) {\n                if (last_bend && last_bend.type === Bend.UP) {\n                    renderRelease(start.x, start.y, last_drawn_width, bend_height);\n                }\n                if (last_bend && last_bend.type === Bend.DOWN) {\n                    renderArrowHead(start.x, start.y, -1);\n                    renderRelease(start.x, start.y, last_drawn_width, bend_height);\n                }\n                if (!last_bend) {\n                    last_drawn_width = bend.draw_width;\n                    renderRelease(start.x, start.y, last_drawn_width, bend_height);\n                }\n            }\n            renderText(start.x + last_drawn_width, bend.text);\n            last_bend = bend;\n            last_bend_draw_width = bend.draw_width;\n            last_bend.x = start.x;\n            start.x += last_drawn_width;\n        }\n        if (!last_bend || last_bend.x == undefined) {\n            throw new RuntimeError('NoLastBendForBend', 'Internal error.');\n        }\n        if (last_bend.type === Bend.UP) {\n            renderArrowHead(last_bend.x + last_drawn_width, bend_height, +1);\n        }\n        else if (last_bend.type === Bend.DOWN) {\n            renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);\n        }\n    }\n}\nBend.TEXT_FONT = Object.assign({}, Element.TEXT_FONT);\nexport { Bend };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}