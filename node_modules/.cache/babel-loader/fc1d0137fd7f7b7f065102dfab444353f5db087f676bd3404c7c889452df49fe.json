{"ast":null,"code":"import { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote } from './typeguard.js';\nimport { log, RuntimeError } from './util.js';\nfunction L(...args) {\n  if (ChordSymbol.DEBUG) log('Vex.Flow.ChordSymbol', args);\n}\nexport var ChordSymbolHorizontalJustify;\n(function (ChordSymbolHorizontalJustify) {\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n  ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(ChordSymbolHorizontalJustify || (ChordSymbolHorizontalJustify = {}));\nexport var ChordSymbolVerticalJustify;\n(function (ChordSymbolVerticalJustify) {\n  ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n  ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(ChordSymbolVerticalJustify || (ChordSymbolVerticalJustify = {}));\nexport var SymbolTypes;\n(function (SymbolTypes) {\n  SymbolTypes[SymbolTypes[\"GLYPH\"] = 1] = \"GLYPH\";\n  SymbolTypes[SymbolTypes[\"TEXT\"] = 2] = \"TEXT\";\n  SymbolTypes[SymbolTypes[\"LINE\"] = 3] = \"LINE\";\n})(SymbolTypes || (SymbolTypes = {}));\nexport var SymbolModifiers;\n(function (SymbolModifiers) {\n  SymbolModifiers[SymbolModifiers[\"NONE\"] = 1] = \"NONE\";\n  SymbolModifiers[SymbolModifiers[\"SUBSCRIPT\"] = 2] = \"SUBSCRIPT\";\n  SymbolModifiers[SymbolModifiers[\"SUPERSCRIPT\"] = 3] = \"SUPERSCRIPT\";\n})(SymbolModifiers || (SymbolModifiers = {}));\nclass ChordSymbol extends Modifier {\n  static get CATEGORY() {\n    return \"ChordSymbol\";\n  }\n  static get superSubRatio() {\n    return ChordSymbol.metrics.global.superSubRatio;\n  }\n  static set NO_TEXT_FORMAT(val) {\n    ChordSymbol.noFormat = val;\n  }\n  static get NO_TEXT_FORMAT() {\n    return ChordSymbol.noFormat;\n  }\n  static getMetricForGlyph(glyphCode) {\n    if (ChordSymbol.metrics.glyphs[glyphCode]) {\n      return ChordSymbol.metrics.glyphs[glyphCode];\n    }\n    return undefined;\n  }\n  static get engravingFontResolution() {\n    return Tables.currentMusicFont().getResolution();\n  }\n  static get spacingBetweenBlocks() {\n    return ChordSymbol.metrics.global.spacing / ChordSymbol.engravingFontResolution;\n  }\n  static getWidthForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0.65;\n    }\n    return metric.advanceWidth / ChordSymbol.engravingFontResolution;\n  }\n  static getYShiftForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0;\n    }\n    return metric.yOffset / ChordSymbol.engravingFontResolution;\n  }\n  static getXShiftForGlyph(glyph) {\n    const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n    if (!metric) {\n      return 0;\n    }\n    return -1 * metric.leftSideBearing / ChordSymbol.engravingFontResolution;\n  }\n  static get superscriptOffset() {\n    return ChordSymbol.metrics.global.superscriptOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get subscriptOffset() {\n    return ChordSymbol.metrics.global.subscriptOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get kerningOffset() {\n    return ChordSymbol.metrics.global.kerningOffset / ChordSymbol.engravingFontResolution;\n  }\n  static get metrics() {\n    const chordSymbol = Tables.currentMusicFont().getMetrics().chordSymbol;\n    if (!chordSymbol) throw new RuntimeError('BadMetrics', `chordSymbol missing`);\n    return chordSymbol;\n  }\n  static get lowerKerningText() {\n    return ChordSymbol.metrics.global.lowerKerningText;\n  }\n  static get upperKerningText() {\n    return ChordSymbol.metrics.global.upperKerningText;\n  }\n  static isSuperscript(block) {\n    return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUPERSCRIPT;\n  }\n  static isSubscript(block) {\n    return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUBSCRIPT;\n  }\n  static get minPadding() {\n    const musicFont = Tables.currentMusicFont();\n    return musicFont.lookupMetric('noteHead.minPadding');\n  }\n  static format(symbols, state) {\n    var _a;\n    if (!symbols || symbols.length === 0) return false;\n    let width = 0;\n    let nonSuperWidth = 0;\n    let leftWidth = 0;\n    let rightWidth = 0;\n    let maxLeftGlyphWidth = 0;\n    let maxRightGlyphWidth = 0;\n    for (const symbol of symbols) {\n      const fontSize = Font.convertSizeToPointValue((_a = symbol.textFont) === null || _a === void 0 ? void 0 : _a.size);\n      const fontAdj = Font.scaleSize(fontSize, 0.05);\n      const glyphAdj = fontAdj * 2;\n      const note = symbol.checkAttachedNote();\n      let symbolWidth = 0;\n      let lineSpaces = 1;\n      let vAlign = false;\n      for (let j = 0; j < symbol.symbolBlocks.length; ++j) {\n        const block = symbol.symbolBlocks[j];\n        const sup = ChordSymbol.isSuperscript(block);\n        const sub = ChordSymbol.isSubscript(block);\n        const superSubScale = sup || sub ? ChordSymbol.superSubRatio : 1;\n        const adj = block.symbolType === SymbolTypes.GLYPH ? glyphAdj * superSubScale : fontAdj * superSubScale;\n        if (sup || sub) {\n          lineSpaces = 2;\n        }\n        const fontSize = symbol.textFormatter.fontSizeInPixels;\n        const superSubFontSize = fontSize * superSubScale;\n        if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined) {\n          block.width = ChordSymbol.getWidthForGlyph(block.glyph) * superSubFontSize;\n          block.yShift += ChordSymbol.getYShiftForGlyph(block.glyph) * superSubFontSize;\n          block.xShift += ChordSymbol.getXShiftForGlyph(block.glyph) * superSubFontSize;\n          block.glyph.scale = block.glyph.scale * adj;\n        } else if (block.symbolType === SymbolTypes.TEXT) {\n          block.width = block.width * superSubFontSize;\n          block.yShift += symbol.getYOffsetForText(block.text) * adj;\n        }\n        if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined && block.glyph.code === ChordSymbol.glyphs.over.code) {\n          lineSpaces = 2;\n        }\n        block.width += ChordSymbol.spacingBetweenBlocks * fontSize * superSubScale;\n        if (sup && j > 0) {\n          const prev = symbol.symbolBlocks[j - 1];\n          if (!ChordSymbol.isSuperscript(prev)) {\n            nonSuperWidth = width;\n          }\n        }\n        if (sub && nonSuperWidth > 0) {\n          vAlign = true;\n          block.xShift = block.xShift + (nonSuperWidth - width);\n          width = nonSuperWidth;\n          nonSuperWidth = 0;\n          symbol.setEnableKerning(false);\n        }\n        if (!sup && !sub) {\n          nonSuperWidth = 0;\n        }\n        block.vAlign = vAlign;\n        width += block.width;\n        symbolWidth = width;\n      }\n      symbol.updateKerningAdjustments();\n      symbol.updateOverBarAdjustments();\n      if (symbol.getVertical() === ChordSymbolVerticalJustify.TOP) {\n        symbol.setTextLine(state.top_text_line);\n        state.top_text_line += lineSpaces;\n      } else {\n        symbol.setTextLine(state.text_line + 1);\n        state.text_line += lineSpaces + 1;\n      }\n      if (symbol.getReportWidth() && isStemmableNote(note)) {\n        const glyphWidth = note.getGlyphProps().getWidth();\n        if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.LEFT) {\n          maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n          leftWidth = Math.max(leftWidth, symbolWidth) + ChordSymbol.minPadding;\n        } else if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.RIGHT) {\n          maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n          rightWidth = Math.max(rightWidth, symbolWidth);\n        } else {\n          leftWidth = Math.max(leftWidth, symbolWidth / 2) + ChordSymbol.minPadding;\n          rightWidth = Math.max(rightWidth, symbolWidth / 2);\n          maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n          maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n        }\n      }\n      width = 0;\n    }\n    const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n    const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n    state.left_shift += leftOverlap;\n    state.right_shift += rightOverlap;\n    return true;\n  }\n  constructor() {\n    super();\n    this.symbolBlocks = [];\n    this.horizontal = ChordSymbolHorizontalJustify.LEFT;\n    this.vertical = ChordSymbolVerticalJustify.TOP;\n    this.useKerning = true;\n    this.reportWidth = true;\n    this.resetFont();\n  }\n  static get TEXT_FONT() {\n    let family = 'Roboto Slab, Times, serif';\n    if (Tables.currentMusicFont().getName() === 'Petaluma') {\n      family = 'PetalumaScript, Arial, sans-serif';\n    }\n    return {\n      family,\n      size: 12,\n      weight: FontWeight.NORMAL,\n      style: FontStyle.NORMAL\n    };\n  }\n  get superscriptOffset() {\n    return ChordSymbol.superscriptOffset * this.textFormatter.fontSizeInPixels;\n  }\n  get subscriptOffset() {\n    return ChordSymbol.subscriptOffset * this.textFormatter.fontSizeInPixels;\n  }\n  setReportWidth(value) {\n    this.reportWidth = value;\n    return this;\n  }\n  getReportWidth() {\n    return this.reportWidth;\n  }\n  updateOverBarAdjustments() {\n    const barIndex = this.symbolBlocks.findIndex(({\n      symbolType,\n      glyph\n    }) => symbolType === SymbolTypes.GLYPH && glyph !== undefined && glyph.code === 'csymDiagonalArrangementSlash');\n    if (barIndex < 0) {\n      return;\n    }\n    const bar = this.symbolBlocks[barIndex];\n    const xoff = bar.width / 4;\n    const yoff = 0.25 * this.textFormatter.fontSizeInPixels;\n    let symIndex = 0;\n    for (symIndex === 0; symIndex < barIndex; ++symIndex) {\n      const symbol = this.symbolBlocks[symIndex];\n      symbol.xShift = symbol.xShift + xoff;\n      symbol.yShift = symbol.yShift - yoff;\n    }\n    for (symIndex = barIndex + 1; symIndex < this.symbolBlocks.length; ++symIndex) {\n      const symbol = this.symbolBlocks[symIndex];\n      symbol.xShift = symbol.xShift - xoff;\n      symbol.yShift = symbol.yShift + yoff;\n    }\n  }\n  updateKerningAdjustments() {\n    let accum = 0;\n    for (let j = 0; j < this.symbolBlocks.length; ++j) {\n      const symbol = this.symbolBlocks[j];\n      accum += this.getKerningAdjustment(j);\n      symbol.xShift += accum;\n    }\n  }\n  getKerningAdjustment(j) {\n    if (!this.useKerning) {\n      return 0;\n    }\n    const currSymbol = this.symbolBlocks[j];\n    const prevSymbol = j > 0 ? this.symbolBlocks[j - 1] : undefined;\n    let adjustment = 0;\n    if (currSymbol.symbolType === SymbolTypes.GLYPH && currSymbol.glyph !== undefined && currSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n      adjustment += currSymbol.glyph.metrics.x_shift;\n    }\n    if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.GLYPH && prevSymbol.glyph !== undefined && prevSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n      adjustment += prevSymbol.glyph.metrics.x_shift;\n    }\n    let preKernUpper = false;\n    let preKernLower = false;\n    if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.TEXT) {\n      preKernUpper = ChordSymbol.upperKerningText.some(xx => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n      preKernLower = ChordSymbol.lowerKerningText.some(xx => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n    }\n    const kerningOffsetPixels = ChordSymbol.kerningOffset * this.textFormatter.fontSizeInPixels;\n    if (preKernUpper && currSymbol.symbolModifier === SymbolModifiers.SUPERSCRIPT) {\n      adjustment += kerningOffsetPixels;\n    }\n    if (preKernLower && currSymbol.symbolType === SymbolTypes.TEXT) {\n      if (currSymbol.text[0] >= 'a' && currSymbol.text[0] <= 'z') {\n        adjustment += kerningOffsetPixels / 2;\n      }\n      if (ChordSymbol.upperKerningText.some(xx => xx === (prevSymbol === null || prevSymbol === void 0 ? void 0 : prevSymbol.text[prevSymbol.text.length - 1]))) {\n        adjustment += kerningOffsetPixels / 2;\n      }\n    }\n    return adjustment;\n  }\n  getSymbolBlock(params = {}) {\n    var _a, _b, _c;\n    const symbolType = (_a = params.symbolType) !== null && _a !== void 0 ? _a : SymbolTypes.TEXT;\n    const symbolBlock = {\n      text: (_b = params.text) !== null && _b !== void 0 ? _b : '',\n      symbolType,\n      symbolModifier: (_c = params.symbolModifier) !== null && _c !== void 0 ? _c : SymbolModifiers.NONE,\n      xShift: 0,\n      yShift: 0,\n      vAlign: false,\n      width: 0\n    };\n    if (symbolType === SymbolTypes.GLYPH && typeof params.glyph === 'string') {\n      const glyphArgs = ChordSymbol.glyphs[params.glyph];\n      const glyphPoints = 20;\n      symbolBlock.glyph = new Glyph(glyphArgs.code, glyphPoints, {\n        category: 'chordSymbol'\n      });\n    } else if (symbolType === SymbolTypes.TEXT) {\n      symbolBlock.width = this.textFormatter.getWidthForTextInEm(symbolBlock.text);\n    } else if (symbolType === SymbolTypes.LINE) {\n      symbolBlock.width = params.width;\n    }\n    return symbolBlock;\n  }\n  addSymbolBlock(parameters) {\n    this.symbolBlocks.push(this.getSymbolBlock(parameters));\n    return this;\n  }\n  addText(text, parameters = {}) {\n    const symbolType = SymbolTypes.TEXT;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, parameters), {\n      text,\n      symbolType\n    }));\n  }\n  addTextSuperscript(text) {\n    const symbolType = SymbolTypes.TEXT;\n    const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n    return this.addSymbolBlock({\n      text,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addTextSubscript(text) {\n    const symbolType = SymbolTypes.TEXT;\n    const symbolModifier = SymbolModifiers.SUBSCRIPT;\n    return this.addSymbolBlock({\n      text,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addGlyphSuperscript(glyph) {\n    const symbolType = SymbolTypes.GLYPH;\n    const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n    return this.addSymbolBlock({\n      glyph,\n      symbolType,\n      symbolModifier\n    });\n  }\n  addGlyph(glyph, params = {}) {\n    const symbolType = SymbolTypes.GLYPH;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, params), {\n      glyph,\n      symbolType\n    }));\n  }\n  addGlyphOrText(text, params = {}) {\n    let str = '';\n    for (let i = 0; i < text.length; ++i) {\n      const char = text[i];\n      if (ChordSymbol.glyphs[char]) {\n        if (str.length > 0) {\n          this.addText(str, params);\n          str = '';\n        }\n        this.addGlyph(char, params);\n      } else {\n        str += char;\n      }\n    }\n    if (str.length > 0) {\n      this.addText(str, params);\n    }\n    return this;\n  }\n  addLine(width, params = {}) {\n    const symbolType = SymbolTypes.LINE;\n    return this.addSymbolBlock(Object.assign(Object.assign({}, params), {\n      symbolType,\n      width\n    }));\n  }\n  setFont(f, size, weight, style) {\n    super.setFont(f, size, weight, style);\n    this.textFormatter = TextFormatter.create(this.textFont);\n    return this;\n  }\n  setEnableKerning(val) {\n    this.useKerning = val;\n    return this;\n  }\n  setVertical(vj) {\n    this.vertical = typeof vj === 'string' ? ChordSymbol.VerticalJustifyString[vj] : vj;\n    return this;\n  }\n  getVertical() {\n    return this.vertical;\n  }\n  setHorizontal(hj) {\n    this.horizontal = typeof hj === 'string' ? ChordSymbol.HorizontalJustifyString[hj] : hj;\n    return this;\n  }\n  getHorizontal() {\n    return this.horizontal;\n  }\n  getWidth() {\n    let width = 0;\n    this.symbolBlocks.forEach(symbol => {\n      width += symbol.vAlign ? 0 : symbol.width;\n    });\n    return width;\n  }\n  getYOffsetForText(text) {\n    var _a;\n    let acc = 0;\n    let i = 0;\n    for (i = 0; i < text.length; ++i) {\n      const metrics = this.textFormatter.getGlyphMetrics(text[i]);\n      if (metrics) {\n        const yMax = (_a = metrics.y_max) !== null && _a !== void 0 ? _a : 0;\n        acc = yMax < acc ? yMax : acc;\n      }\n    }\n    const resolution = this.textFormatter.getResolution();\n    return i > 0 ? -1 * (acc / resolution) : 0;\n  }\n  draw() {\n    const ctx = this.checkContext();\n    const note = this.checkAttachedNote();\n    this.setRendered();\n    ctx.save();\n    this.applyStyle();\n    ctx.openGroup('chordsymbol', this.getAttribute('id'));\n    const start = note.getModifierStartXY(Modifier.Position.ABOVE, this.index);\n    ctx.setFont(this.textFont);\n    let y;\n    const hasStem = note.hasStem();\n    const stave = note.checkStave();\n    if (this.vertical === ChordSymbolVerticalJustify.BOTTOM) {\n      y = stave.getYForBottomText(this.text_line + Tables.TEXT_HEIGHT_OFFSET_HACK);\n      if (hasStem) {\n        const stem_ext = note.checkStem().getExtents();\n        const spacing = stave.getSpacingBetweenLines();\n        const stem_base = note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY;\n        y = Math.max(y, stem_base + spacing * (this.text_line + 2));\n      }\n    } else {\n      const topY = Math.min(...note.getYs());\n      y = Math.min(stave.getYForTopText(this.text_line), topY - 10);\n      if (hasStem) {\n        const stem_ext = note.checkStem().getExtents();\n        const spacing = stave.getSpacingBetweenLines();\n        y = Math.min(y, stem_ext.topY - 5 - spacing * this.text_line);\n      }\n    }\n    let x = start.x;\n    if (this.horizontal === ChordSymbolHorizontalJustify.LEFT) {\n      x = start.x;\n    } else if (this.horizontal === ChordSymbolHorizontalJustify.RIGHT) {\n      x = start.x + this.getWidth();\n    } else if (this.horizontal === ChordSymbolHorizontalJustify.CENTER) {\n      x = start.x - this.getWidth() / 2;\n    } else {\n      x = note.getStemX() - this.getWidth() / 2;\n    }\n    L('Rendering ChordSymbol: ', this.textFormatter, x, y);\n    this.symbolBlocks.forEach(symbol => {\n      const isSuper = ChordSymbol.isSuperscript(symbol);\n      const isSub = ChordSymbol.isSubscript(symbol);\n      let curY = y;\n      L('shift was ', symbol.xShift, symbol.yShift);\n      L('curY pre sub ', curY);\n      if (isSuper) {\n        curY += this.superscriptOffset;\n      }\n      if (isSub) {\n        curY += this.subscriptOffset;\n      }\n      L('curY sup/sub ', curY);\n      if (symbol.symbolType === SymbolTypes.TEXT) {\n        if (isSuper || isSub) {\n          ctx.save();\n          if (this.textFont) {\n            const {\n              family,\n              size,\n              weight,\n              style\n            } = this.textFont;\n            const smallerFontSize = Font.scaleSize(size, ChordSymbol.superSubRatio);\n            ctx.setFont(family, smallerFontSize, weight, style);\n          }\n        }\n        L('Rendering Text: ', symbol.text, x + symbol.xShift, curY + symbol.yShift);\n        ctx.fillText(symbol.text, x + symbol.xShift, curY + symbol.yShift);\n        if (isSuper || isSub) {\n          ctx.restore();\n        }\n      } else if (symbol.symbolType === SymbolTypes.GLYPH && symbol.glyph) {\n        curY += symbol.yShift;\n        L('Rendering Glyph: ', symbol.glyph.code, x + symbol.xShift, curY);\n        symbol.glyph.render(ctx, x + symbol.xShift, curY);\n      } else if (symbol.symbolType === SymbolTypes.LINE) {\n        L('Rendering Line : ', symbol.width, x, curY);\n        ctx.beginPath();\n        ctx.setLineWidth(1);\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + symbol.width, curY);\n        ctx.stroke();\n      }\n      x += symbol.width;\n      if (symbol.vAlign) {\n        x += symbol.xShift;\n      }\n    });\n    ctx.closeGroup();\n    this.restoreStyle();\n    ctx.restore();\n  }\n}\nChordSymbol.DEBUG = false;\nChordSymbol.HorizontalJustify = ChordSymbolHorizontalJustify;\nChordSymbol.HorizontalJustifyString = {\n  left: ChordSymbolHorizontalJustify.LEFT,\n  right: ChordSymbolHorizontalJustify.RIGHT,\n  center: ChordSymbolHorizontalJustify.CENTER,\n  centerStem: ChordSymbolHorizontalJustify.CENTER_STEM\n};\nChordSymbol.VerticalJustify = ChordSymbolVerticalJustify;\nChordSymbol.VerticalJustifyString = {\n  top: ChordSymbolVerticalJustify.TOP,\n  above: ChordSymbolVerticalJustify.TOP,\n  below: ChordSymbolVerticalJustify.BOTTOM,\n  bottom: ChordSymbolVerticalJustify.BOTTOM\n};\nChordSymbol.glyphs = {\n  diminished: {\n    code: 'csymDiminished'\n  },\n  dim: {\n    code: 'csymDiminished'\n  },\n  halfDiminished: {\n    code: 'csymHalfDiminished'\n  },\n  '+': {\n    code: 'csymAugmented'\n  },\n  augmented: {\n    code: 'csymAugmented'\n  },\n  majorSeventh: {\n    code: 'csymMajorSeventh'\n  },\n  minor: {\n    code: 'csymMinor'\n  },\n  '-': {\n    code: 'csymMinor'\n  },\n  '(': {\n    code: 'csymParensLeftTall'\n  },\n  leftParen: {\n    code: 'csymParensLeftTall'\n  },\n  ')': {\n    code: 'csymParensRightTall'\n  },\n  rightParen: {\n    code: 'csymParensRightTall'\n  },\n  leftBracket: {\n    code: 'csymBracketLeftTall'\n  },\n  rightBracket: {\n    code: 'csymBracketRightTall'\n  },\n  leftParenTall: {\n    code: 'csymParensLeftVeryTall'\n  },\n  rightParenTall: {\n    code: 'csymParensRightVeryTall'\n  },\n  '/': {\n    code: 'csymDiagonalArrangementSlash'\n  },\n  over: {\n    code: 'csymDiagonalArrangementSlash'\n  },\n  '#': {\n    code: 'accidentalSharp'\n  },\n  b: {\n    code: 'accidentalFlat'\n  }\n};\nChordSymbol.symbolTypes = SymbolTypes;\nChordSymbol.symbolModifiers = SymbolModifiers;\nChordSymbol.noFormat = false;\nexport { ChordSymbol };","map":{"version":3,"names":["Font","FontStyle","FontWeight","Glyph","Modifier","Tables","TextFormatter","isStemmableNote","log","RuntimeError","L","args","ChordSymbol","DEBUG","ChordSymbolHorizontalJustify","ChordSymbolVerticalJustify","SymbolTypes","SymbolModifiers","CATEGORY","superSubRatio","metrics","global","NO_TEXT_FORMAT","val","noFormat","getMetricForGlyph","glyphCode","glyphs","undefined","engravingFontResolution","currentMusicFont","getResolution","spacingBetweenBlocks","spacing","getWidthForGlyph","glyph","metric","code","advanceWidth","getYShiftForGlyph","yOffset","getXShiftForGlyph","leftSideBearing","superscriptOffset","subscriptOffset","kerningOffset","chordSymbol","getMetrics","lowerKerningText","upperKerningText","isSuperscript","block","symbolModifier","SUPERSCRIPT","isSubscript","SUBSCRIPT","minPadding","musicFont","lookupMetric","format","symbols","state","_a","length","width","nonSuperWidth","leftWidth","rightWidth","maxLeftGlyphWidth","maxRightGlyphWidth","symbol","fontSize","convertSizeToPointValue","textFont","size","fontAdj","scaleSize","glyphAdj","note","checkAttachedNote","symbolWidth","lineSpaces","vAlign","j","symbolBlocks","sup","sub","superSubScale","adj","symbolType","GLYPH","textFormatter","fontSizeInPixels","superSubFontSize","yShift","xShift","scale","TEXT","getYOffsetForText","text","over","prev","setEnableKerning","updateKerningAdjustments","updateOverBarAdjustments","getVertical","TOP","setTextLine","top_text_line","text_line","getReportWidth","glyphWidth","getGlyphProps","getWidth","getHorizontal","LEFT","Math","max","RIGHT","rightOverlap","min","right_shift","leftOverlap","left_shift","constructor","horizontal","vertical","useKerning","reportWidth","resetFont","TEXT_FONT","family","getName","weight","NORMAL","style","setReportWidth","value","barIndex","findIndex","bar","xoff","yoff","symIndex","accum","getKerningAdjustment","currSymbol","prevSymbol","adjustment","x_shift","preKernUpper","preKernLower","some","xx","kerningOffsetPixels","getSymbolBlock","params","_b","_c","symbolBlock","NONE","glyphArgs","glyphPoints","category","getWidthForTextInEm","LINE","addSymbolBlock","parameters","push","addText","Object","assign","addTextSuperscript","addTextSubscript","addGlyphSuperscript","addGlyph","addGlyphOrText","str","i","char","addLine","setFont","f","create","setVertical","vj","VerticalJustifyString","setHorizontal","hj","HorizontalJustifyString","forEach","acc","getGlyphMetrics","yMax","y_max","resolution","draw","ctx","checkContext","setRendered","save","applyStyle","openGroup","getAttribute","start","getModifierStartXY","Position","ABOVE","index","y","hasStem","stave","checkStave","BOTTOM","getYForBottomText","TEXT_HEIGHT_OFFSET_HACK","stem_ext","checkStem","getExtents","getSpacingBetweenLines","stem_base","getStemDirection","baseY","topY","getYs","getYForTopText","x","CENTER","getStemX","isSuper","isSub","curY","smallerFontSize","fillText","restore","render","beginPath","setLineWidth","moveTo","lineTo","stroke","closeGroup","restoreStyle","HorizontalJustify","left","right","center","centerStem","CENTER_STEM","VerticalJustify","top","above","below","bottom","diminished","dim","halfDiminished","augmented","majorSeventh","minor","leftParen","rightParen","leftBracket","rightBracket","leftParenTall","rightParenTall","b","symbolTypes","symbolModifiers"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/chordsymbol.js"],"sourcesContent":["import { Font, FontStyle, FontWeight } from './font.js';\nimport { Glyph } from './glyph.js';\nimport { Modifier } from './modifier.js';\nimport { Tables } from './tables.js';\nimport { TextFormatter } from './textformatter.js';\nimport { isStemmableNote } from './typeguard.js';\nimport { log, RuntimeError } from './util.js';\nfunction L(...args) {\n    if (ChordSymbol.DEBUG)\n        log('Vex.Flow.ChordSymbol', args);\n}\nexport var ChordSymbolHorizontalJustify;\n(function (ChordSymbolHorizontalJustify) {\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"LEFT\"] = 1] = \"LEFT\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER\"] = 2] = \"CENTER\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"RIGHT\"] = 3] = \"RIGHT\";\n    ChordSymbolHorizontalJustify[ChordSymbolHorizontalJustify[\"CENTER_STEM\"] = 4] = \"CENTER_STEM\";\n})(ChordSymbolHorizontalJustify || (ChordSymbolHorizontalJustify = {}));\nexport var ChordSymbolVerticalJustify;\n(function (ChordSymbolVerticalJustify) {\n    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"TOP\"] = 1] = \"TOP\";\n    ChordSymbolVerticalJustify[ChordSymbolVerticalJustify[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(ChordSymbolVerticalJustify || (ChordSymbolVerticalJustify = {}));\nexport var SymbolTypes;\n(function (SymbolTypes) {\n    SymbolTypes[SymbolTypes[\"GLYPH\"] = 1] = \"GLYPH\";\n    SymbolTypes[SymbolTypes[\"TEXT\"] = 2] = \"TEXT\";\n    SymbolTypes[SymbolTypes[\"LINE\"] = 3] = \"LINE\";\n})(SymbolTypes || (SymbolTypes = {}));\nexport var SymbolModifiers;\n(function (SymbolModifiers) {\n    SymbolModifiers[SymbolModifiers[\"NONE\"] = 1] = \"NONE\";\n    SymbolModifiers[SymbolModifiers[\"SUBSCRIPT\"] = 2] = \"SUBSCRIPT\";\n    SymbolModifiers[SymbolModifiers[\"SUPERSCRIPT\"] = 3] = \"SUPERSCRIPT\";\n})(SymbolModifiers || (SymbolModifiers = {}));\nclass ChordSymbol extends Modifier {\n    static get CATEGORY() {\n        return \"ChordSymbol\";\n    }\n    static get superSubRatio() {\n        return ChordSymbol.metrics.global.superSubRatio;\n    }\n    static set NO_TEXT_FORMAT(val) {\n        ChordSymbol.noFormat = val;\n    }\n    static get NO_TEXT_FORMAT() {\n        return ChordSymbol.noFormat;\n    }\n    static getMetricForGlyph(glyphCode) {\n        if (ChordSymbol.metrics.glyphs[glyphCode]) {\n            return ChordSymbol.metrics.glyphs[glyphCode];\n        }\n        return undefined;\n    }\n    static get engravingFontResolution() {\n        return Tables.currentMusicFont().getResolution();\n    }\n    static get spacingBetweenBlocks() {\n        return ChordSymbol.metrics.global.spacing / ChordSymbol.engravingFontResolution;\n    }\n    static getWidthForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0.65;\n        }\n        return metric.advanceWidth / ChordSymbol.engravingFontResolution;\n    }\n    static getYShiftForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0;\n        }\n        return metric.yOffset / ChordSymbol.engravingFontResolution;\n    }\n    static getXShiftForGlyph(glyph) {\n        const metric = ChordSymbol.getMetricForGlyph(glyph.code);\n        if (!metric) {\n            return 0;\n        }\n        return (-1 * metric.leftSideBearing) / ChordSymbol.engravingFontResolution;\n    }\n    static get superscriptOffset() {\n        return ChordSymbol.metrics.global.superscriptOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get subscriptOffset() {\n        return ChordSymbol.metrics.global.subscriptOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get kerningOffset() {\n        return ChordSymbol.metrics.global.kerningOffset / ChordSymbol.engravingFontResolution;\n    }\n    static get metrics() {\n        const chordSymbol = Tables.currentMusicFont().getMetrics().chordSymbol;\n        if (!chordSymbol)\n            throw new RuntimeError('BadMetrics', `chordSymbol missing`);\n        return chordSymbol;\n    }\n    static get lowerKerningText() {\n        return ChordSymbol.metrics.global.lowerKerningText;\n    }\n    static get upperKerningText() {\n        return ChordSymbol.metrics.global.upperKerningText;\n    }\n    static isSuperscript(block) {\n        return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUPERSCRIPT;\n    }\n    static isSubscript(block) {\n        return block.symbolModifier !== undefined && block.symbolModifier === SymbolModifiers.SUBSCRIPT;\n    }\n    static get minPadding() {\n        const musicFont = Tables.currentMusicFont();\n        return musicFont.lookupMetric('noteHead.minPadding');\n    }\n    static format(symbols, state) {\n        var _a;\n        if (!symbols || symbols.length === 0)\n            return false;\n        let width = 0;\n        let nonSuperWidth = 0;\n        let leftWidth = 0;\n        let rightWidth = 0;\n        let maxLeftGlyphWidth = 0;\n        let maxRightGlyphWidth = 0;\n        for (const symbol of symbols) {\n            const fontSize = Font.convertSizeToPointValue((_a = symbol.textFont) === null || _a === void 0 ? void 0 : _a.size);\n            const fontAdj = Font.scaleSize(fontSize, 0.05);\n            const glyphAdj = fontAdj * 2;\n            const note = symbol.checkAttachedNote();\n            let symbolWidth = 0;\n            let lineSpaces = 1;\n            let vAlign = false;\n            for (let j = 0; j < symbol.symbolBlocks.length; ++j) {\n                const block = symbol.symbolBlocks[j];\n                const sup = ChordSymbol.isSuperscript(block);\n                const sub = ChordSymbol.isSubscript(block);\n                const superSubScale = sup || sub ? ChordSymbol.superSubRatio : 1;\n                const adj = block.symbolType === SymbolTypes.GLYPH ? glyphAdj * superSubScale : fontAdj * superSubScale;\n                if (sup || sub) {\n                    lineSpaces = 2;\n                }\n                const fontSize = symbol.textFormatter.fontSizeInPixels;\n                const superSubFontSize = fontSize * superSubScale;\n                if (block.symbolType === SymbolTypes.GLYPH && block.glyph !== undefined) {\n                    block.width = ChordSymbol.getWidthForGlyph(block.glyph) * superSubFontSize;\n                    block.yShift += ChordSymbol.getYShiftForGlyph(block.glyph) * superSubFontSize;\n                    block.xShift += ChordSymbol.getXShiftForGlyph(block.glyph) * superSubFontSize;\n                    block.glyph.scale = block.glyph.scale * adj;\n                }\n                else if (block.symbolType === SymbolTypes.TEXT) {\n                    block.width = block.width * superSubFontSize;\n                    block.yShift += symbol.getYOffsetForText(block.text) * adj;\n                }\n                if (block.symbolType === SymbolTypes.GLYPH &&\n                    block.glyph !== undefined &&\n                    block.glyph.code === ChordSymbol.glyphs.over.code) {\n                    lineSpaces = 2;\n                }\n                block.width += ChordSymbol.spacingBetweenBlocks * fontSize * superSubScale;\n                if (sup && j > 0) {\n                    const prev = symbol.symbolBlocks[j - 1];\n                    if (!ChordSymbol.isSuperscript(prev)) {\n                        nonSuperWidth = width;\n                    }\n                }\n                if (sub && nonSuperWidth > 0) {\n                    vAlign = true;\n                    block.xShift = block.xShift + (nonSuperWidth - width);\n                    width = nonSuperWidth;\n                    nonSuperWidth = 0;\n                    symbol.setEnableKerning(false);\n                }\n                if (!sup && !sub) {\n                    nonSuperWidth = 0;\n                }\n                block.vAlign = vAlign;\n                width += block.width;\n                symbolWidth = width;\n            }\n            symbol.updateKerningAdjustments();\n            symbol.updateOverBarAdjustments();\n            if (symbol.getVertical() === ChordSymbolVerticalJustify.TOP) {\n                symbol.setTextLine(state.top_text_line);\n                state.top_text_line += lineSpaces;\n            }\n            else {\n                symbol.setTextLine(state.text_line + 1);\n                state.text_line += lineSpaces + 1;\n            }\n            if (symbol.getReportWidth() && isStemmableNote(note)) {\n                const glyphWidth = note.getGlyphProps().getWidth();\n                if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.LEFT) {\n                    maxLeftGlyphWidth = Math.max(glyphWidth, maxLeftGlyphWidth);\n                    leftWidth = Math.max(leftWidth, symbolWidth) + ChordSymbol.minPadding;\n                }\n                else if (symbol.getHorizontal() === ChordSymbolHorizontalJustify.RIGHT) {\n                    maxRightGlyphWidth = Math.max(glyphWidth, maxRightGlyphWidth);\n                    rightWidth = Math.max(rightWidth, symbolWidth);\n                }\n                else {\n                    leftWidth = Math.max(leftWidth, symbolWidth / 2) + ChordSymbol.minPadding;\n                    rightWidth = Math.max(rightWidth, symbolWidth / 2);\n                    maxLeftGlyphWidth = Math.max(glyphWidth / 2, maxLeftGlyphWidth);\n                    maxRightGlyphWidth = Math.max(glyphWidth / 2, maxRightGlyphWidth);\n                }\n            }\n            width = 0;\n        }\n        const rightOverlap = Math.min(Math.max(rightWidth - maxRightGlyphWidth, 0), Math.max(rightWidth - state.right_shift, 0));\n        const leftOverlap = Math.min(Math.max(leftWidth - maxLeftGlyphWidth, 0), Math.max(leftWidth - state.left_shift, 0));\n        state.left_shift += leftOverlap;\n        state.right_shift += rightOverlap;\n        return true;\n    }\n    constructor() {\n        super();\n        this.symbolBlocks = [];\n        this.horizontal = ChordSymbolHorizontalJustify.LEFT;\n        this.vertical = ChordSymbolVerticalJustify.TOP;\n        this.useKerning = true;\n        this.reportWidth = true;\n        this.resetFont();\n    }\n    static get TEXT_FONT() {\n        let family = 'Roboto Slab, Times, serif';\n        if (Tables.currentMusicFont().getName() === 'Petaluma') {\n            family = 'PetalumaScript, Arial, sans-serif';\n        }\n        return {\n            family,\n            size: 12,\n            weight: FontWeight.NORMAL,\n            style: FontStyle.NORMAL,\n        };\n    }\n    get superscriptOffset() {\n        return ChordSymbol.superscriptOffset * this.textFormatter.fontSizeInPixels;\n    }\n    get subscriptOffset() {\n        return ChordSymbol.subscriptOffset * this.textFormatter.fontSizeInPixels;\n    }\n    setReportWidth(value) {\n        this.reportWidth = value;\n        return this;\n    }\n    getReportWidth() {\n        return this.reportWidth;\n    }\n    updateOverBarAdjustments() {\n        const barIndex = this.symbolBlocks.findIndex(({ symbolType, glyph }) => symbolType === SymbolTypes.GLYPH && glyph !== undefined && glyph.code === 'csymDiagonalArrangementSlash');\n        if (barIndex < 0) {\n            return;\n        }\n        const bar = this.symbolBlocks[barIndex];\n        const xoff = bar.width / 4;\n        const yoff = 0.25 * this.textFormatter.fontSizeInPixels;\n        let symIndex = 0;\n        for (symIndex === 0; symIndex < barIndex; ++symIndex) {\n            const symbol = this.symbolBlocks[symIndex];\n            symbol.xShift = symbol.xShift + xoff;\n            symbol.yShift = symbol.yShift - yoff;\n        }\n        for (symIndex = barIndex + 1; symIndex < this.symbolBlocks.length; ++symIndex) {\n            const symbol = this.symbolBlocks[symIndex];\n            symbol.xShift = symbol.xShift - xoff;\n            symbol.yShift = symbol.yShift + yoff;\n        }\n    }\n    updateKerningAdjustments() {\n        let accum = 0;\n        for (let j = 0; j < this.symbolBlocks.length; ++j) {\n            const symbol = this.symbolBlocks[j];\n            accum += this.getKerningAdjustment(j);\n            symbol.xShift += accum;\n        }\n    }\n    getKerningAdjustment(j) {\n        if (!this.useKerning) {\n            return 0;\n        }\n        const currSymbol = this.symbolBlocks[j];\n        const prevSymbol = j > 0 ? this.symbolBlocks[j - 1] : undefined;\n        let adjustment = 0;\n        if (currSymbol.symbolType === SymbolTypes.GLYPH &&\n            currSymbol.glyph !== undefined &&\n            currSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n            adjustment += currSymbol.glyph.metrics.x_shift;\n        }\n        if (prevSymbol !== undefined &&\n            prevSymbol.symbolType === SymbolTypes.GLYPH &&\n            prevSymbol.glyph !== undefined &&\n            prevSymbol.glyph.code === ChordSymbol.glyphs.over.code) {\n            adjustment += prevSymbol.glyph.metrics.x_shift;\n        }\n        let preKernUpper = false;\n        let preKernLower = false;\n        if (prevSymbol !== undefined && prevSymbol.symbolType === SymbolTypes.TEXT) {\n            preKernUpper = ChordSymbol.upperKerningText.some((xx) => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n            preKernLower = ChordSymbol.lowerKerningText.some((xx) => xx === prevSymbol.text[prevSymbol.text.length - 1]);\n        }\n        const kerningOffsetPixels = ChordSymbol.kerningOffset * this.textFormatter.fontSizeInPixels;\n        if (preKernUpper && currSymbol.symbolModifier === SymbolModifiers.SUPERSCRIPT) {\n            adjustment += kerningOffsetPixels;\n        }\n        if (preKernLower && currSymbol.symbolType === SymbolTypes.TEXT) {\n            if (currSymbol.text[0] >= 'a' && currSymbol.text[0] <= 'z') {\n                adjustment += kerningOffsetPixels / 2;\n            }\n            if (ChordSymbol.upperKerningText.some((xx) => xx === (prevSymbol === null || prevSymbol === void 0 ? void 0 : prevSymbol.text[prevSymbol.text.length - 1]))) {\n                adjustment += kerningOffsetPixels / 2;\n            }\n        }\n        return adjustment;\n    }\n    getSymbolBlock(params = {}) {\n        var _a, _b, _c;\n        const symbolType = (_a = params.symbolType) !== null && _a !== void 0 ? _a : SymbolTypes.TEXT;\n        const symbolBlock = {\n            text: (_b = params.text) !== null && _b !== void 0 ? _b : '',\n            symbolType,\n            symbolModifier: (_c = params.symbolModifier) !== null && _c !== void 0 ? _c : SymbolModifiers.NONE,\n            xShift: 0,\n            yShift: 0,\n            vAlign: false,\n            width: 0,\n        };\n        if (symbolType === SymbolTypes.GLYPH && typeof params.glyph === 'string') {\n            const glyphArgs = ChordSymbol.glyphs[params.glyph];\n            const glyphPoints = 20;\n            symbolBlock.glyph = new Glyph(glyphArgs.code, glyphPoints, { category: 'chordSymbol' });\n        }\n        else if (symbolType === SymbolTypes.TEXT) {\n            symbolBlock.width = this.textFormatter.getWidthForTextInEm(symbolBlock.text);\n        }\n        else if (symbolType === SymbolTypes.LINE) {\n            symbolBlock.width = params.width;\n        }\n        return symbolBlock;\n    }\n    addSymbolBlock(parameters) {\n        this.symbolBlocks.push(this.getSymbolBlock(parameters));\n        return this;\n    }\n    addText(text, parameters = {}) {\n        const symbolType = SymbolTypes.TEXT;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, parameters), { text, symbolType }));\n    }\n    addTextSuperscript(text) {\n        const symbolType = SymbolTypes.TEXT;\n        const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n        return this.addSymbolBlock({ text, symbolType, symbolModifier });\n    }\n    addTextSubscript(text) {\n        const symbolType = SymbolTypes.TEXT;\n        const symbolModifier = SymbolModifiers.SUBSCRIPT;\n        return this.addSymbolBlock({ text, symbolType, symbolModifier });\n    }\n    addGlyphSuperscript(glyph) {\n        const symbolType = SymbolTypes.GLYPH;\n        const symbolModifier = SymbolModifiers.SUPERSCRIPT;\n        return this.addSymbolBlock({ glyph, symbolType, symbolModifier });\n    }\n    addGlyph(glyph, params = {}) {\n        const symbolType = SymbolTypes.GLYPH;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, params), { glyph, symbolType }));\n    }\n    addGlyphOrText(text, params = {}) {\n        let str = '';\n        for (let i = 0; i < text.length; ++i) {\n            const char = text[i];\n            if (ChordSymbol.glyphs[char]) {\n                if (str.length > 0) {\n                    this.addText(str, params);\n                    str = '';\n                }\n                this.addGlyph(char, params);\n            }\n            else {\n                str += char;\n            }\n        }\n        if (str.length > 0) {\n            this.addText(str, params);\n        }\n        return this;\n    }\n    addLine(width, params = {}) {\n        const symbolType = SymbolTypes.LINE;\n        return this.addSymbolBlock(Object.assign(Object.assign({}, params), { symbolType, width }));\n    }\n    setFont(f, size, weight, style) {\n        super.setFont(f, size, weight, style);\n        this.textFormatter = TextFormatter.create(this.textFont);\n        return this;\n    }\n    setEnableKerning(val) {\n        this.useKerning = val;\n        return this;\n    }\n    setVertical(vj) {\n        this.vertical = typeof vj === 'string' ? ChordSymbol.VerticalJustifyString[vj] : vj;\n        return this;\n    }\n    getVertical() {\n        return this.vertical;\n    }\n    setHorizontal(hj) {\n        this.horizontal = typeof hj === 'string' ? ChordSymbol.HorizontalJustifyString[hj] : hj;\n        return this;\n    }\n    getHorizontal() {\n        return this.horizontal;\n    }\n    getWidth() {\n        let width = 0;\n        this.symbolBlocks.forEach((symbol) => {\n            width += symbol.vAlign ? 0 : symbol.width;\n        });\n        return width;\n    }\n    getYOffsetForText(text) {\n        var _a;\n        let acc = 0;\n        let i = 0;\n        for (i = 0; i < text.length; ++i) {\n            const metrics = this.textFormatter.getGlyphMetrics(text[i]);\n            if (metrics) {\n                const yMax = (_a = metrics.y_max) !== null && _a !== void 0 ? _a : 0;\n                acc = yMax < acc ? yMax : acc;\n            }\n        }\n        const resolution = this.textFormatter.getResolution();\n        return i > 0 ? -1 * (acc / resolution) : 0;\n    }\n    draw() {\n        const ctx = this.checkContext();\n        const note = this.checkAttachedNote();\n        this.setRendered();\n        ctx.save();\n        this.applyStyle();\n        ctx.openGroup('chordsymbol', this.getAttribute('id'));\n        const start = note.getModifierStartXY(Modifier.Position.ABOVE, this.index);\n        ctx.setFont(this.textFont);\n        let y;\n        const hasStem = note.hasStem();\n        const stave = note.checkStave();\n        if (this.vertical === ChordSymbolVerticalJustify.BOTTOM) {\n            y = stave.getYForBottomText(this.text_line + Tables.TEXT_HEIGHT_OFFSET_HACK);\n            if (hasStem) {\n                const stem_ext = note.checkStem().getExtents();\n                const spacing = stave.getSpacingBetweenLines();\n                const stem_base = note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY;\n                y = Math.max(y, stem_base + spacing * (this.text_line + 2));\n            }\n        }\n        else {\n            const topY = Math.min(...note.getYs());\n            y = Math.min(stave.getYForTopText(this.text_line), topY - 10);\n            if (hasStem) {\n                const stem_ext = note.checkStem().getExtents();\n                const spacing = stave.getSpacingBetweenLines();\n                y = Math.min(y, stem_ext.topY - 5 - spacing * this.text_line);\n            }\n        }\n        let x = start.x;\n        if (this.horizontal === ChordSymbolHorizontalJustify.LEFT) {\n            x = start.x;\n        }\n        else if (this.horizontal === ChordSymbolHorizontalJustify.RIGHT) {\n            x = start.x + this.getWidth();\n        }\n        else if (this.horizontal === ChordSymbolHorizontalJustify.CENTER) {\n            x = start.x - this.getWidth() / 2;\n        }\n        else {\n            x = note.getStemX() - this.getWidth() / 2;\n        }\n        L('Rendering ChordSymbol: ', this.textFormatter, x, y);\n        this.symbolBlocks.forEach((symbol) => {\n            const isSuper = ChordSymbol.isSuperscript(symbol);\n            const isSub = ChordSymbol.isSubscript(symbol);\n            let curY = y;\n            L('shift was ', symbol.xShift, symbol.yShift);\n            L('curY pre sub ', curY);\n            if (isSuper) {\n                curY += this.superscriptOffset;\n            }\n            if (isSub) {\n                curY += this.subscriptOffset;\n            }\n            L('curY sup/sub ', curY);\n            if (symbol.symbolType === SymbolTypes.TEXT) {\n                if (isSuper || isSub) {\n                    ctx.save();\n                    if (this.textFont) {\n                        const { family, size, weight, style } = this.textFont;\n                        const smallerFontSize = Font.scaleSize(size, ChordSymbol.superSubRatio);\n                        ctx.setFont(family, smallerFontSize, weight, style);\n                    }\n                }\n                L('Rendering Text: ', symbol.text, x + symbol.xShift, curY + symbol.yShift);\n                ctx.fillText(symbol.text, x + symbol.xShift, curY + symbol.yShift);\n                if (isSuper || isSub) {\n                    ctx.restore();\n                }\n            }\n            else if (symbol.symbolType === SymbolTypes.GLYPH && symbol.glyph) {\n                curY += symbol.yShift;\n                L('Rendering Glyph: ', symbol.glyph.code, x + symbol.xShift, curY);\n                symbol.glyph.render(ctx, x + symbol.xShift, curY);\n            }\n            else if (symbol.symbolType === SymbolTypes.LINE) {\n                L('Rendering Line : ', symbol.width, x, curY);\n                ctx.beginPath();\n                ctx.setLineWidth(1);\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + symbol.width, curY);\n                ctx.stroke();\n            }\n            x += symbol.width;\n            if (symbol.vAlign) {\n                x += symbol.xShift;\n            }\n        });\n        ctx.closeGroup();\n        this.restoreStyle();\n        ctx.restore();\n    }\n}\nChordSymbol.DEBUG = false;\nChordSymbol.HorizontalJustify = ChordSymbolHorizontalJustify;\nChordSymbol.HorizontalJustifyString = {\n    left: ChordSymbolHorizontalJustify.LEFT,\n    right: ChordSymbolHorizontalJustify.RIGHT,\n    center: ChordSymbolHorizontalJustify.CENTER,\n    centerStem: ChordSymbolHorizontalJustify.CENTER_STEM,\n};\nChordSymbol.VerticalJustify = ChordSymbolVerticalJustify;\nChordSymbol.VerticalJustifyString = {\n    top: ChordSymbolVerticalJustify.TOP,\n    above: ChordSymbolVerticalJustify.TOP,\n    below: ChordSymbolVerticalJustify.BOTTOM,\n    bottom: ChordSymbolVerticalJustify.BOTTOM,\n};\nChordSymbol.glyphs = {\n    diminished: {\n        code: 'csymDiminished',\n    },\n    dim: {\n        code: 'csymDiminished',\n    },\n    halfDiminished: {\n        code: 'csymHalfDiminished',\n    },\n    '+': {\n        code: 'csymAugmented',\n    },\n    augmented: {\n        code: 'csymAugmented',\n    },\n    majorSeventh: {\n        code: 'csymMajorSeventh',\n    },\n    minor: {\n        code: 'csymMinor',\n    },\n    '-': {\n        code: 'csymMinor',\n    },\n    '(': {\n        code: 'csymParensLeftTall',\n    },\n    leftParen: {\n        code: 'csymParensLeftTall',\n    },\n    ')': {\n        code: 'csymParensRightTall',\n    },\n    rightParen: {\n        code: 'csymParensRightTall',\n    },\n    leftBracket: {\n        code: 'csymBracketLeftTall',\n    },\n    rightBracket: {\n        code: 'csymBracketRightTall',\n    },\n    leftParenTall: {\n        code: 'csymParensLeftVeryTall',\n    },\n    rightParenTall: {\n        code: 'csymParensRightVeryTall',\n    },\n    '/': {\n        code: 'csymDiagonalArrangementSlash',\n    },\n    over: {\n        code: 'csymDiagonalArrangementSlash',\n    },\n    '#': {\n        code: 'accidentalSharp',\n    },\n    b: {\n        code: 'accidentalFlat',\n    },\n};\nChordSymbol.symbolTypes = SymbolTypes;\nChordSymbol.symbolModifiers = SymbolModifiers;\nChordSymbol.noFormat = false;\nexport { ChordSymbol };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}