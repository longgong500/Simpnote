{"ast":null,"code":"import { Font, FontStyle, FontWeight } from './font.js';\nimport { log } from './util.js';\nfunction L(...args) {\n  if (TextFormatter.DEBUG) log('Vex.Flow.TextFormatter', args);\n}\nconst textWidthCache = {};\nconst textHeightCache = {};\nconst registry = {};\nclass TextFormatter {\n  static getFontFamilies() {\n    const registeredFonts = [];\n    for (const fontFamily in registry) {\n      const formatterInfo = registry[fontFamily];\n      registeredFonts.push(Object.assign({}, formatterInfo));\n    }\n    return registeredFonts;\n  }\n  static create(requestedFont = {}) {\n    L('create: ', requestedFont);\n    if (!requestedFont.family) {\n      requestedFont.family = Font.SANS_SERIF;\n    }\n    const candidates = [];\n    const requestedFamilies = requestedFont.family.split(/\\s*,\\s*/);\n    for (const requestedFamily of requestedFamilies) {\n      for (const fontFamily in registry) {\n        if (fontFamily.startsWith(requestedFamily)) {\n          candidates.push(registry[fontFamily]);\n        }\n      }\n      if (candidates.length > 0) {\n        break;\n      }\n    }\n    let formatter;\n    if (candidates.length === 0) {\n      formatter = new TextFormatter(Object.values(registry)[0]);\n    } else if (candidates.length === 1) {\n      formatter = new TextFormatter(candidates[0]);\n    } else {\n      const bold = Font.isBold(requestedFont.weight);\n      const italic = Font.isItalic(requestedFont.style);\n      const perfectMatch = candidates.find(f => f.bold === bold && f.italic === italic);\n      if (perfectMatch) {\n        formatter = new TextFormatter(perfectMatch);\n      } else {\n        const partialMatch = candidates.find(f => f.italic === italic || f.bold === bold);\n        if (partialMatch) {\n          formatter = new TextFormatter(partialMatch);\n        } else {\n          formatter = new TextFormatter(candidates[0]);\n        }\n      }\n    }\n    const fontSize = requestedFont.size;\n    if (typeof fontSize !== 'undefined') {\n      const fontSizeInPt = Font.convertSizeToPointValue(fontSize);\n      formatter.setFontSize(fontSizeInPt);\n    }\n    return formatter;\n  }\n  static getInfo(fontFamily) {\n    return registry[fontFamily];\n  }\n  static registerInfo(info, overwrite = false) {\n    L('registerInfo: ', info, overwrite);\n    const fontFamily = info.family;\n    const currFontInfo = registry[fontFamily];\n    if (currFontInfo === undefined || overwrite) {\n      registry[fontFamily] = info;\n    }\n  }\n  constructor(formatterInfo) {\n    this.family = '';\n    this.size = 14;\n    this.resolution = 1000;\n    this.glyphs = {};\n    this.serifs = false;\n    this.monospaced = false;\n    this.italic = false;\n    this.bold = false;\n    this.superscriptOffset = 0;\n    this.subscriptOffset = 0;\n    this.maxSizeGlyph = '@';\n    this.cacheKey = '';\n    this.updateParams(formatterInfo);\n  }\n  get localHeightCache() {\n    var _a;\n    if (textHeightCache[this.cacheKey] === undefined) {\n      textHeightCache[this.cacheKey] = {};\n    }\n    return (_a = textHeightCache[this.cacheKey]) !== null && _a !== void 0 ? _a : {};\n  }\n  updateParams(params) {\n    if (params.family) this.family = params.family;\n    if (params.resolution) this.resolution = params.resolution;\n    if (params.glyphs) this.glyphs = params.glyphs;\n    if (params.serifs) this.serifs = params.serifs;\n    if (params.monospaced) this.monospaced = params.monospaced;\n    if (params.italic) this.italic = params.italic;\n    if (params.bold) this.bold = params.bold;\n    if (params.maxSizeGlyph) this.maxSizeGlyph = params.maxSizeGlyph;\n    if (params.superscriptOffset) this.superscriptOffset = params.superscriptOffset;\n    if (params.subscriptOffset) this.subscriptOffset = params.subscriptOffset;\n    this.updateCacheKey();\n  }\n  updateCacheKey() {\n    const family = this.family.replace(/\\s+/g, '_');\n    const size = this.size;\n    const weight = this.bold ? FontWeight.BOLD : FontWeight.NORMAL;\n    const style = this.italic ? FontStyle.ITALIC : FontStyle.NORMAL;\n    this.cacheKey = `${family}%${size}%${weight}%${style}`;\n  }\n  getGlyphMetrics(character) {\n    if (this.glyphs[character]) {\n      return this.glyphs[character];\n    } else {\n      return this.glyphs[this.maxSizeGlyph];\n    }\n  }\n  get maxHeight() {\n    const metrics = this.getGlyphMetrics(this.maxSizeGlyph);\n    return metrics.ha / this.resolution * this.fontSizeInPixels;\n  }\n  getWidthForCharacterInEm(c) {\n    var _a;\n    const metrics = this.getGlyphMetrics(c);\n    if (!metrics) {\n      return 0.65;\n    } else {\n      const advanceWidth = (_a = metrics.advanceWidth) !== null && _a !== void 0 ? _a : 0;\n      return advanceWidth / this.resolution;\n    }\n  }\n  getYForCharacterInPx(c) {\n    const metrics = this.getGlyphMetrics(c);\n    const rv = {\n      yMin: 0,\n      yMax: this.maxHeight,\n      height: this.maxHeight\n    };\n    if (!metrics) {\n      return rv;\n    } else {\n      if (typeof metrics.y_min === 'number') {\n        rv.yMin = metrics.y_min / this.resolution * this.fontSizeInPixels;\n      }\n      if (typeof metrics.y_max === 'number') {\n        rv.yMax = metrics.y_max / this.resolution * this.fontSizeInPixels;\n      }\n      rv.height = rv.yMax - rv.yMin;\n      return rv;\n    }\n  }\n  getYForStringInPx(str) {\n    const entry = this.localHeightCache;\n    const extent = {\n      yMin: 0,\n      yMax: this.maxHeight,\n      height: this.maxHeight\n    };\n    const cache = entry[str];\n    if (cache !== undefined) {\n      return cache;\n    }\n    for (let i = 0; i < str.length; ++i) {\n      const curY = this.getYForCharacterInPx(str[i]);\n      extent.yMin = Math.min(extent.yMin, curY.yMin);\n      extent.yMax = Math.max(extent.yMax, curY.yMax);\n      extent.height = extent.yMax - extent.yMin;\n    }\n    entry[str] = extent;\n    return extent;\n  }\n  getWidthForTextInEm(text) {\n    const key = this.cacheKey;\n    let cachedWidths = textWidthCache[key];\n    if (cachedWidths === undefined) {\n      cachedWidths = {};\n      textWidthCache[key] = cachedWidths;\n    }\n    let width = cachedWidths[text];\n    if (width === undefined) {\n      width = 0;\n      for (let i = 0; i < text.length; ++i) {\n        width += this.getWidthForCharacterInEm(text[i]);\n      }\n      cachedWidths[text] = width;\n    }\n    return width;\n  }\n  getWidthForTextInPx(text) {\n    return this.getWidthForTextInEm(text) * this.fontSizeInPixels;\n  }\n  setFontSize(size) {\n    this.size = size;\n    this.updateCacheKey();\n    return this;\n  }\n  get fontSizeInPixels() {\n    return this.size * Font.scaleToPxFrom.pt;\n  }\n  getResolution() {\n    return this.resolution;\n  }\n}\nTextFormatter.DEBUG = false;\nexport { TextFormatter };","map":{"version":3,"names":["Font","FontStyle","FontWeight","log","L","args","TextFormatter","DEBUG","textWidthCache","textHeightCache","registry","getFontFamilies","registeredFonts","fontFamily","formatterInfo","push","Object","assign","create","requestedFont","family","SANS_SERIF","candidates","requestedFamilies","split","requestedFamily","startsWith","length","formatter","values","bold","isBold","weight","italic","isItalic","style","perfectMatch","find","f","partialMatch","fontSize","size","fontSizeInPt","convertSizeToPointValue","setFontSize","getInfo","registerInfo","info","overwrite","currFontInfo","undefined","constructor","resolution","glyphs","serifs","monospaced","superscriptOffset","subscriptOffset","maxSizeGlyph","cacheKey","updateParams","localHeightCache","_a","params","updateCacheKey","replace","BOLD","NORMAL","ITALIC","getGlyphMetrics","character","maxHeight","metrics","ha","fontSizeInPixels","getWidthForCharacterInEm","c","advanceWidth","getYForCharacterInPx","rv","yMin","yMax","height","y_min","y_max","getYForStringInPx","str","entry","extent","cache","i","curY","Math","min","max","getWidthForTextInEm","text","key","cachedWidths","width","getWidthForTextInPx","scaleToPxFrom","pt","getResolution"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/textformatter.js"],"sourcesContent":["import { Font, FontStyle, FontWeight } from './font.js';\nimport { log } from './util.js';\nfunction L(...args) {\n    if (TextFormatter.DEBUG)\n        log('Vex.Flow.TextFormatter', args);\n}\nconst textWidthCache = {};\nconst textHeightCache = {};\nconst registry = {};\nclass TextFormatter {\n    static getFontFamilies() {\n        const registeredFonts = [];\n        for (const fontFamily in registry) {\n            const formatterInfo = registry[fontFamily];\n            registeredFonts.push(Object.assign({}, formatterInfo));\n        }\n        return registeredFonts;\n    }\n    static create(requestedFont = {}) {\n        L('create: ', requestedFont);\n        if (!requestedFont.family) {\n            requestedFont.family = Font.SANS_SERIF;\n        }\n        const candidates = [];\n        const requestedFamilies = requestedFont.family.split(/\\s*,\\s*/);\n        for (const requestedFamily of requestedFamilies) {\n            for (const fontFamily in registry) {\n                if (fontFamily.startsWith(requestedFamily)) {\n                    candidates.push(registry[fontFamily]);\n                }\n            }\n            if (candidates.length > 0) {\n                break;\n            }\n        }\n        let formatter;\n        if (candidates.length === 0) {\n            formatter = new TextFormatter(Object.values(registry)[0]);\n        }\n        else if (candidates.length === 1) {\n            formatter = new TextFormatter(candidates[0]);\n        }\n        else {\n            const bold = Font.isBold(requestedFont.weight);\n            const italic = Font.isItalic(requestedFont.style);\n            const perfectMatch = candidates.find((f) => f.bold === bold && f.italic === italic);\n            if (perfectMatch) {\n                formatter = new TextFormatter(perfectMatch);\n            }\n            else {\n                const partialMatch = candidates.find((f) => f.italic === italic || f.bold === bold);\n                if (partialMatch) {\n                    formatter = new TextFormatter(partialMatch);\n                }\n                else {\n                    formatter = new TextFormatter(candidates[0]);\n                }\n            }\n        }\n        const fontSize = requestedFont.size;\n        if (typeof fontSize !== 'undefined') {\n            const fontSizeInPt = Font.convertSizeToPointValue(fontSize);\n            formatter.setFontSize(fontSizeInPt);\n        }\n        return formatter;\n    }\n    static getInfo(fontFamily) {\n        return registry[fontFamily];\n    }\n    static registerInfo(info, overwrite = false) {\n        L('registerInfo: ', info, overwrite);\n        const fontFamily = info.family;\n        const currFontInfo = registry[fontFamily];\n        if (currFontInfo === undefined || overwrite) {\n            registry[fontFamily] = info;\n        }\n    }\n    constructor(formatterInfo) {\n        this.family = '';\n        this.size = 14;\n        this.resolution = 1000;\n        this.glyphs = {};\n        this.serifs = false;\n        this.monospaced = false;\n        this.italic = false;\n        this.bold = false;\n        this.superscriptOffset = 0;\n        this.subscriptOffset = 0;\n        this.maxSizeGlyph = '@';\n        this.cacheKey = '';\n        this.updateParams(formatterInfo);\n    }\n    get localHeightCache() {\n        var _a;\n        if (textHeightCache[this.cacheKey] === undefined) {\n            textHeightCache[this.cacheKey] = {};\n        }\n        return (_a = textHeightCache[this.cacheKey]) !== null && _a !== void 0 ? _a : {};\n    }\n    updateParams(params) {\n        if (params.family)\n            this.family = params.family;\n        if (params.resolution)\n            this.resolution = params.resolution;\n        if (params.glyphs)\n            this.glyphs = params.glyphs;\n        if (params.serifs)\n            this.serifs = params.serifs;\n        if (params.monospaced)\n            this.monospaced = params.monospaced;\n        if (params.italic)\n            this.italic = params.italic;\n        if (params.bold)\n            this.bold = params.bold;\n        if (params.maxSizeGlyph)\n            this.maxSizeGlyph = params.maxSizeGlyph;\n        if (params.superscriptOffset)\n            this.superscriptOffset = params.superscriptOffset;\n        if (params.subscriptOffset)\n            this.subscriptOffset = params.subscriptOffset;\n        this.updateCacheKey();\n    }\n    updateCacheKey() {\n        const family = this.family.replace(/\\s+/g, '_');\n        const size = this.size;\n        const weight = this.bold ? FontWeight.BOLD : FontWeight.NORMAL;\n        const style = this.italic ? FontStyle.ITALIC : FontStyle.NORMAL;\n        this.cacheKey = `${family}%${size}%${weight}%${style}`;\n    }\n    getGlyphMetrics(character) {\n        if (this.glyphs[character]) {\n            return this.glyphs[character];\n        }\n        else {\n            return this.glyphs[this.maxSizeGlyph];\n        }\n    }\n    get maxHeight() {\n        const metrics = this.getGlyphMetrics(this.maxSizeGlyph);\n        return (metrics.ha / this.resolution) * this.fontSizeInPixels;\n    }\n    getWidthForCharacterInEm(c) {\n        var _a;\n        const metrics = this.getGlyphMetrics(c);\n        if (!metrics) {\n            return 0.65;\n        }\n        else {\n            const advanceWidth = (_a = metrics.advanceWidth) !== null && _a !== void 0 ? _a : 0;\n            return advanceWidth / this.resolution;\n        }\n    }\n    getYForCharacterInPx(c) {\n        const metrics = this.getGlyphMetrics(c);\n        const rv = { yMin: 0, yMax: this.maxHeight, height: this.maxHeight };\n        if (!metrics) {\n            return rv;\n        }\n        else {\n            if (typeof metrics.y_min === 'number') {\n                rv.yMin = (metrics.y_min / this.resolution) * this.fontSizeInPixels;\n            }\n            if (typeof metrics.y_max === 'number') {\n                rv.yMax = (metrics.y_max / this.resolution) * this.fontSizeInPixels;\n            }\n            rv.height = rv.yMax - rv.yMin;\n            return rv;\n        }\n    }\n    getYForStringInPx(str) {\n        const entry = this.localHeightCache;\n        const extent = { yMin: 0, yMax: this.maxHeight, height: this.maxHeight };\n        const cache = entry[str];\n        if (cache !== undefined) {\n            return cache;\n        }\n        for (let i = 0; i < str.length; ++i) {\n            const curY = this.getYForCharacterInPx(str[i]);\n            extent.yMin = Math.min(extent.yMin, curY.yMin);\n            extent.yMax = Math.max(extent.yMax, curY.yMax);\n            extent.height = extent.yMax - extent.yMin;\n        }\n        entry[str] = extent;\n        return extent;\n    }\n    getWidthForTextInEm(text) {\n        const key = this.cacheKey;\n        let cachedWidths = textWidthCache[key];\n        if (cachedWidths === undefined) {\n            cachedWidths = {};\n            textWidthCache[key] = cachedWidths;\n        }\n        let width = cachedWidths[text];\n        if (width === undefined) {\n            width = 0;\n            for (let i = 0; i < text.length; ++i) {\n                width += this.getWidthForCharacterInEm(text[i]);\n            }\n            cachedWidths[text] = width;\n        }\n        return width;\n    }\n    getWidthForTextInPx(text) {\n        return this.getWidthForTextInEm(text) * this.fontSizeInPixels;\n    }\n    setFontSize(size) {\n        this.size = size;\n        this.updateCacheKey();\n        return this;\n    }\n    get fontSizeInPixels() {\n        return this.size * Font.scaleToPxFrom.pt;\n    }\n    getResolution() {\n        return this.resolution;\n    }\n}\nTextFormatter.DEBUG = false;\nexport { TextFormatter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}