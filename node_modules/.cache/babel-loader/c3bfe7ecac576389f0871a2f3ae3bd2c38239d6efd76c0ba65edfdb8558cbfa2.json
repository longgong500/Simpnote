{"ast":null,"code":"import { Beam } from './beam.js';\nimport { Font } from './font.js';\nimport { Fraction } from './fraction.js';\nimport { ModifierContext } from './modifiercontext.js';\nimport { Stave } from './stave.js';\nimport { StaveConnector } from './staveconnector.js';\nimport { Tables } from './tables.js';\nimport { TickContext } from './tickcontext.js';\nimport { isNote, isStaveNote } from './typeguard.js';\nimport { defined, log, midLine, RuntimeError, sumArray } from './util.js';\nimport { Voice } from './voice.js';\nfunction createContexts(voices, makeContext, addToContext) {\n  if (voices.length == 0) return {\n    map: {},\n    array: [],\n    list: [],\n    resolutionMultiplier: 0\n  };\n  const tickToContextMap = {};\n  const tickList = [];\n  const contexts = [];\n  const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);\n  voices.forEach((voice, voiceIndex) => {\n    const ticksUsed = new Fraction(0, resolutionMultiplier);\n    voice.getTickables().forEach(tickable => {\n      const integerTicks = ticksUsed.numerator;\n      if (!tickToContextMap[integerTicks]) {\n        const newContext = makeContext({\n          tickID: integerTicks\n        });\n        contexts.push(newContext);\n        tickToContextMap[integerTicks] = newContext;\n        tickList.push(integerTicks);\n      }\n      addToContext(tickable, tickToContextMap[integerTicks], voiceIndex);\n      ticksUsed.add(tickable.getTicks());\n    });\n  });\n  return {\n    map: tickToContextMap,\n    array: contexts,\n    list: tickList.sort((a, b) => a - b),\n    resolutionMultiplier\n  };\n}\nfunction L(...args) {\n  if (Formatter.DEBUG) log('Vex.Flow.Formatter', args);\n}\nfunction getRestLineForNextNoteGroup(notes, currRestLine, currNoteIndex, compare) {\n  let nextRestLine = currRestLine;\n  for (let noteIndex = currNoteIndex + 1; noteIndex < notes.length; noteIndex++) {\n    const note = notes[noteIndex];\n    if (isNote(note) && !note.isRest() && !note.shouldIgnoreTicks()) {\n      nextRestLine = note.getLineForRest();\n      break;\n    }\n  }\n  if (compare && currRestLine !== nextRestLine) {\n    const top = Math.max(currRestLine, nextRestLine);\n    const bot = Math.min(currRestLine, nextRestLine);\n    nextRestLine = midLine(top, bot);\n  }\n  return nextRestLine;\n}\nclass Formatter {\n  static SimpleFormat(notes, x = 0, {\n    paddingBetween = 10\n  } = {}) {\n    notes.reduce((accumulator, note) => {\n      note.addToModifierContext(new ModifierContext());\n      const tick = new TickContext().addTickable(note).preFormat();\n      const metrics = tick.getMetrics();\n      tick.setX(accumulator + metrics.totalLeftPx);\n      return accumulator + tick.getWidth() + metrics.totalRightPx + paddingBetween;\n    }, x);\n  }\n  static plotDebugging(ctx, formatter, xPos, y1, y2, options) {\n    options = Object.assign({\n      stavePadding: Tables.currentMusicFont().lookupMetric('stave.padding')\n    }, options);\n    const x = xPos + options.stavePadding;\n    const contextGaps = formatter.contextGaps;\n    function stroke(x1, x2, color) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(1);\n      ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);\n    }\n    ctx.save();\n    ctx.setFont(Font.SANS_SERIF, 8);\n    contextGaps.gaps.forEach(gap => {\n      stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');\n      ctx.setFillStyle('green');\n      ctx.fillText(Math.round(gap.x2 - gap.x1).toString(), x + gap.x1, y2 + 12);\n    });\n    ctx.setFillStyle('red');\n    ctx.fillText(`Loss: ${(formatter.totalCost || 0).toFixed(2)} Shift: ${(formatter.totalShift || 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);\n    ctx.restore();\n  }\n  static FormatAndDraw(ctx, stave, notes, params) {\n    let options = {\n      auto_beam: false,\n      align_rests: false\n    };\n    if (typeof params === 'object') {\n      options = Object.assign(Object.assign({}, options), params);\n    } else if (typeof params === 'boolean') {\n      options.auto_beam = params;\n    }\n    const voice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes);\n    const beams = options.auto_beam ? Beam.applyAndGetBeams(voice) : [];\n    new Formatter().joinVoices([voice]).formatToStave([voice], stave, {\n      align_rests: options.align_rests,\n      stave\n    });\n    voice.setStave(stave).draw(ctx, stave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n    return voice.getBoundingBox();\n  }\n  static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autobeam, params) {\n    let opts = {\n      auto_beam: autobeam,\n      align_rests: false\n    };\n    if (typeof params === 'object') {\n      opts = Object.assign(Object.assign({}, opts), params);\n    } else if (typeof params === 'boolean') {\n      opts.auto_beam = params;\n    }\n    const notevoice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes);\n    const tabvoice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(tabnotes);\n    const beams = opts.auto_beam ? Beam.applyAndGetBeams(notevoice) : [];\n    new Formatter().joinVoices([notevoice]).joinVoices([tabvoice]).formatToStave([notevoice, tabvoice], stave, {\n      align_rests: opts.align_rests\n    });\n    notevoice.draw(ctx, stave);\n    tabvoice.draw(ctx, tabstave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n    new StaveConnector(stave, tabstave).setContext(ctx).draw();\n  }\n  static AlignRestsToNotes(tickables, alignAllNotes, alignTuplets) {\n    tickables.forEach((currTickable, index) => {\n      if (isStaveNote(currTickable) && currTickable.isRest()) {\n        if (currTickable.getTuplet() && !alignTuplets) {\n          return;\n        }\n        const position = currTickable.getGlyphProps().position.toUpperCase();\n        if (position !== 'R/4' && position !== 'B/4') {\n          return;\n        }\n        if (alignAllNotes || currTickable.getBeam()) {\n          const props = currTickable.getKeyProps()[0];\n          if (index === 0) {\n            props.line = getRestLineForNextNoteGroup(tickables, props.line, index, false);\n          } else if (index > 0 && index < tickables.length) {\n            const prevTickable = tickables[index - 1];\n            if (isStaveNote(prevTickable)) {\n              if (prevTickable.isRest()) {\n                props.line = prevTickable.getKeyProps()[0].line;\n              } else {\n                const restLine = prevTickable.getLineForRest();\n                props.line = getRestLineForNextNoteGroup(tickables, restLine, index, true);\n              }\n            }\n          }\n          currTickable.setKeyLine(0, props.line);\n        }\n      }\n    });\n  }\n  constructor(options) {\n    this.formatterOptions = Object.assign({\n      globalSoftmax: false,\n      softmaxFactor: Tables.SOFTMAX_FACTOR,\n      maxIterations: 5\n    }, options);\n    this.justifyWidth = 0;\n    this.totalCost = 0;\n    this.totalShift = 0;\n    this.durationStats = {};\n    this.minTotalWidth = 0;\n    this.hasMinTotalWidth = false;\n    this.tickContexts = {\n      map: {},\n      array: [],\n      list: [],\n      resolutionMultiplier: 0\n    };\n    this.modifierContexts = [];\n    this.contextGaps = {\n      total: 0,\n      gaps: []\n    };\n    this.voices = [];\n    this.lossHistory = [];\n  }\n  alignRests(voices, alignAllNotes) {\n    if (!voices || !voices.length) {\n      throw new RuntimeError('BadArgument', 'No voices to format rests');\n    }\n    voices.forEach(voice => Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));\n  }\n  preCalculateMinTotalWidth(voices) {\n    const unalignedPadding = Tables.currentMusicFont().lookupMetric('stave.unalignedNotePadding');\n    let unalignedCtxCount = 0;\n    let wsum = 0;\n    let dsum = 0;\n    const widths = [];\n    const durations = [];\n    if (this.hasMinTotalWidth) return this.minTotalWidth;\n    if (!voices) {\n      throw new RuntimeError('BadArgument', \"'voices' required to run preCalculateMinTotalWidth\");\n    }\n    this.createTickContexts(voices);\n    const {\n      list: contextList,\n      map: contextMap\n    } = this.tickContexts;\n    this.minTotalWidth = 0;\n    contextList.forEach(tick => {\n      const context = contextMap[tick];\n      context.preFormat();\n      if (context.getTickables().length < voices.length) {\n        unalignedCtxCount += 1;\n      }\n      context.getTickables().forEach(t => {\n        wsum += t.getMetrics().width;\n        dsum += t.getTicks().value();\n        widths.push(t.getMetrics().width);\n        durations.push(t.getTicks().value());\n      });\n      const width = context.getWidth();\n      this.minTotalWidth += width;\n    });\n    this.hasMinTotalWidth = true;\n    const wavg = wsum > 0 ? wsum / widths.length : 1 / widths.length;\n    const wvar = sumArray(widths.map(ll => Math.pow(ll - wavg, 2)));\n    const wpads = Math.pow(wvar / widths.length, 0.5) / wavg;\n    const davg = dsum / durations.length;\n    const dvar = sumArray(durations.map(ll => Math.pow(ll - davg, 2)));\n    const dpads = Math.pow(dvar / durations.length, 0.5) / davg;\n    const padmax = Math.max(dpads, wpads) * contextList.length * unalignedPadding;\n    const unalignedPad = unalignedPadding * unalignedCtxCount;\n    return this.minTotalWidth + Math.max(unalignedPad, padmax);\n  }\n  getMinTotalWidth() {\n    if (!this.hasMinTotalWidth) {\n      throw new RuntimeError('NoMinTotalWidth', \"Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'\");\n    }\n    return this.minTotalWidth;\n  }\n  static getResolutionMultiplier(voices) {\n    if (!voices || !voices.length) {\n      throw new RuntimeError('BadArgument', 'No voices to format');\n    }\n    const totalTicks = voices[0].getTotalTicks();\n    const resolutionMultiplier = voices.reduce((accumulator, voice) => {\n      if (!voice.getTotalTicks().equals(totalTicks)) {\n        throw new RuntimeError('TickMismatch', 'Voices should have same total note duration in ticks.');\n      }\n      if (voice.getMode() === Voice.Mode.STRICT && !voice.isComplete()) {\n        throw new RuntimeError('IncompleteVoice', 'Voice does not have enough notes.');\n      }\n      return Math.max(accumulator, Fraction.LCM(accumulator, voice.getResolutionMultiplier()));\n    }, 1);\n    return resolutionMultiplier;\n  }\n  createModifierContexts(voices) {\n    if (voices.length == 0) return;\n    const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);\n    const tickToContextMap = new Map();\n    const contexts = [];\n    voices.forEach(voice => {\n      const ticksUsed = new Fraction(0, resolutionMultiplier);\n      voice.getTickables().forEach(tickable => {\n        const integerTicks = ticksUsed.numerator;\n        let staveTickToContextMap = tickToContextMap.get(tickable.getStave());\n        if (!staveTickToContextMap) {\n          tickToContextMap.set(tickable.getStave(), {});\n          staveTickToContextMap = tickToContextMap.get(tickable.getStave());\n        }\n        if (!(staveTickToContextMap ? staveTickToContextMap[integerTicks] : undefined)) {\n          const newContext = new ModifierContext();\n          contexts.push(newContext);\n          staveTickToContextMap[integerTicks] = newContext;\n        }\n        tickable.addToModifierContext(staveTickToContextMap[integerTicks]);\n        ticksUsed.add(tickable.getTicks());\n      });\n    });\n    this.modifierContexts.push({\n      map: tickToContextMap,\n      array: contexts,\n      resolutionMultiplier\n    });\n  }\n  createTickContexts(voices) {\n    const fn = (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex);\n    const contexts = createContexts(voices, tick => new TickContext(tick), fn);\n    this.tickContexts = contexts;\n    const contextArray = this.tickContexts.array;\n    contextArray.forEach(context => {\n      context.tContexts = contextArray;\n    });\n    return contexts;\n  }\n  getTickContexts() {\n    return this.tickContexts;\n  }\n  preFormat(justifyWidth = 0, renderingContext, voicesParam, stave) {\n    const contexts = this.tickContexts;\n    if (!contexts) {\n      throw new RuntimeError('NoTickContexts', 'preFormat requires TickContexts');\n    }\n    const {\n      list: contextList,\n      map: contextMap\n    } = contexts;\n    this.lossHistory = [];\n    if (voicesParam && stave) {\n      voicesParam.forEach(voice => voice.setStave(stave).preFormat());\n    }\n    let x = 0;\n    let shift = 0;\n    this.minTotalWidth = 0;\n    let totalTicks = 0;\n    contextList.forEach(tick => {\n      const context = contextMap[tick];\n      context.preFormat();\n      const width = context.getWidth();\n      this.minTotalWidth += width;\n      const maxTicks = context.getMaxTicks().value();\n      totalTicks += maxTicks;\n      const metrics = context.getMetrics();\n      x = x + shift + metrics.totalLeftPx;\n      context.setX(x);\n      shift = width - metrics.totalLeftPx;\n    });\n    const {\n      globalSoftmax,\n      softmaxFactor,\n      maxIterations\n    } = this.formatterOptions;\n    const exp = tick => Math.pow(softmaxFactor, contextMap[tick].getMaxTicks().value() / totalTicks);\n    const expTicksUsed = sumArray(contextList.map(exp));\n    this.minTotalWidth = x + shift;\n    this.hasMinTotalWidth = true;\n    if (justifyWidth <= 0) return this.evaluate();\n    const firstContext = contextMap[contextList[0]];\n    const lastContext = contextMap[contextList[contextList.length - 1]];\n    function calculateIdealDistances(adjustedJustifyWidth) {\n      const distances = contextList.map((tick, i) => {\n        const context = contextMap[tick];\n        const voices = context.getTickablesByVoice();\n        let backTickable;\n        if (i > 0) {\n          const prevContext = contextMap[contextList[i - 1]];\n          for (let j = i - 1; j >= 0; j--) {\n            const backTick = contextMap[contextList[j]];\n            const backVoices = backTick.getTickablesByVoice();\n            const matchingVoices = [];\n            Object.keys(voices).forEach(v => {\n              if (backVoices[v]) {\n                matchingVoices.push(v);\n              }\n            });\n            if (matchingVoices.length > 0) {\n              let maxTicks = 0;\n              let maxNegativeShiftPx = Infinity;\n              let expectedDistance = 0;\n              matchingVoices.forEach(v => {\n                const ticks = backVoices[v].getTicks().value();\n                if (ticks > maxTicks) {\n                  backTickable = backVoices[v];\n                  maxTicks = ticks;\n                }\n                const thisTickable = voices[v];\n                const insideLeftEdge = thisTickable.getX() - (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);\n                const backMetrics = backVoices[v].getMetrics();\n                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx;\n                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);\n              });\n              maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - (prevContext.getX() + adjustedJustifyWidth * 0.05));\n              if (globalSoftmax) {\n                const t = totalTicks;\n                expectedDistance = Math.pow(softmaxFactor, maxTicks / t) / expTicksUsed * adjustedJustifyWidth;\n              } else if (typeof backTickable !== 'undefined') {\n                expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;\n              }\n              return {\n                expectedDistance,\n                maxNegativeShiftPx,\n                fromTickable: backTickable\n              };\n            }\n          }\n        }\n        return {\n          expectedDistance: 0,\n          fromTickablePx: 0,\n          maxNegativeShiftPx: 0\n        };\n      });\n      return distances;\n    }\n    function shiftToIdealDistances(idealDistances) {\n      const centerX = adjustedJustifyWidth / 2;\n      let spaceAccum = 0;\n      contextList.forEach((tick, index) => {\n        const context = contextMap[tick];\n        if (index > 0) {\n          const contextX = context.getX();\n          const ideal = idealDistances[index];\n          const errorPx = defined(ideal.fromTickable).getX() + ideal.expectedDistance - (contextX + spaceAccum);\n          let negativeShiftPx = 0;\n          if (errorPx > 0) {\n            spaceAccum += errorPx;\n          } else if (errorPx < 0) {\n            negativeShiftPx = Math.min(ideal.maxNegativeShiftPx, Math.abs(errorPx));\n            spaceAccum += -negativeShiftPx;\n          }\n          context.setX(contextX + spaceAccum);\n        }\n        context.getCenterAlignedTickables().forEach(tickable => {\n          tickable.setCenterXShift(centerX - context.getX());\n        });\n      });\n      return lastContext.getX() - firstContext.getX();\n    }\n    const adjustedJustifyWidth = justifyWidth - lastContext.getMetrics().notePx - lastContext.getMetrics().totalRightPx - firstContext.getMetrics().totalLeftPx;\n    const musicFont = Tables.currentMusicFont();\n    const configMinPadding = musicFont.lookupMetric('stave.endPaddingMin');\n    const configMaxPadding = musicFont.lookupMetric('stave.endPaddingMax');\n    const leftPadding = musicFont.lookupMetric('stave.padding');\n    let targetWidth = adjustedJustifyWidth;\n    const distances = calculateIdealDistances(targetWidth);\n    let actualWidth = shiftToIdealDistances(distances);\n    if (contextList.length === 1) return 0;\n    const calcMinDistance = (targetWidth, distances) => {\n      let mdCalc = targetWidth / 2;\n      if (distances.length > 1) {\n        for (let di = 1; di < distances.length; ++di) {\n          mdCalc = Math.min(distances[di].expectedDistance / 2, mdCalc);\n        }\n      }\n      return mdCalc;\n    };\n    const minDistance = calcMinDistance(targetWidth, distances);\n    const paddingMaxCalc = curTargetWidth => {\n      let lastTickablePadding = 0;\n      const lastTickable = lastContext && lastContext.getMaxTickable();\n      if (lastTickable) {\n        const voice = lastTickable.getVoice();\n        if (voice.getTicksUsed().value() > voice.getTotalTicks().value()) {\n          return configMaxPadding * 2 < minDistance ? minDistance : configMaxPadding;\n        }\n        const tickWidth = lastTickable.getWidth();\n        lastTickablePadding = voice.softmax(lastContext.getMaxTicks().value()) * curTargetWidth - (tickWidth + leftPadding);\n      }\n      return configMaxPadding * 2 < lastTickablePadding ? lastTickablePadding : configMaxPadding;\n    };\n    let paddingMax = paddingMaxCalc(targetWidth);\n    let paddingMin = paddingMax - (configMaxPadding - configMinPadding);\n    const maxX = adjustedJustifyWidth - paddingMin;\n    let iterations = maxIterations;\n    while (actualWidth > maxX && iterations > 0 || actualWidth + paddingMax < maxX && iterations > 1) {\n      targetWidth -= actualWidth - maxX;\n      paddingMax = paddingMaxCalc(targetWidth);\n      paddingMin = paddingMax - (configMaxPadding - configMinPadding);\n      actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n      iterations--;\n    }\n    this.justifyWidth = justifyWidth;\n    return this.evaluate();\n  }\n  evaluate() {\n    const contexts = this.tickContexts;\n    const justifyWidth = this.justifyWidth;\n    this.contextGaps = {\n      total: 0,\n      gaps: []\n    };\n    contexts.list.forEach((tick, index) => {\n      if (index === 0) return;\n      const prevTick = contexts.list[index - 1];\n      const prevContext = contexts.map[prevTick];\n      const context = contexts.map[tick];\n      const prevMetrics = prevContext.getMetrics();\n      const currMetrics = context.getMetrics();\n      const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx;\n      const insideLeftEdge = context.getX() - currMetrics.totalLeftPx;\n      const gap = insideLeftEdge - insideRightEdge;\n      this.contextGaps.total += gap;\n      this.contextGaps.gaps.push({\n        x1: insideRightEdge,\n        x2: insideLeftEdge\n      });\n      context.getFormatterMetrics().freedom.left = gap;\n      prevContext.getFormatterMetrics().freedom.right = gap;\n    });\n    this.durationStats = {};\n    const durationStats = this.durationStats;\n    function updateStats(duration, space) {\n      const stats = durationStats[duration];\n      if (stats === undefined) {\n        durationStats[duration] = {\n          mean: space,\n          count: 1\n        };\n      } else {\n        stats.count += 1;\n        stats.mean = (stats.mean + space) / 2;\n      }\n    }\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note, i, notes) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getMetrics();\n        const formatterMetrics = note.getFormatterMetrics();\n        const leftNoteEdge = note.getX() + metrics.notePx + metrics.modRightPx + metrics.rightDisplacedHeadPx;\n        let space = 0;\n        if (i < notes.length - 1) {\n          const rightNote = notes[i + 1];\n          const rightMetrics = rightNote.getMetrics();\n          const rightNoteEdge = rightNote.getX() - rightMetrics.modLeftPx - rightMetrics.leftDisplacedHeadPx;\n          space = rightNoteEdge - leftNoteEdge;\n          formatterMetrics.space.used = rightNote.getX() - note.getX();\n          rightNote.getFormatterMetrics().freedom.left = space;\n        } else {\n          space = justifyWidth - leftNoteEdge;\n          formatterMetrics.space.used = justifyWidth - note.getX();\n        }\n        formatterMetrics.freedom.right = space;\n        updateStats(duration, formatterMetrics.space.used);\n      });\n    });\n    let totalDeviation = 0;\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach(note => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getFormatterMetrics();\n        metrics.space.mean = durationStats[duration].mean;\n        metrics.duration = duration;\n        metrics.iterations += 1;\n        metrics.space.deviation = metrics.space.used - metrics.space.mean;\n        totalDeviation += Math.pow(metrics.space.deviation, 2);\n      });\n    });\n    this.totalCost = Math.sqrt(totalDeviation);\n    this.lossHistory.push(this.totalCost);\n    return this.totalCost;\n  }\n  tune(options) {\n    var _a;\n    const contexts = this.tickContexts;\n    if (!contexts) {\n      return 0;\n    }\n    const alpha = (_a = options === null || options === void 0 ? void 0 : options.alpha) !== null && _a !== void 0 ? _a : 0.5;\n    function move(current, shift, prev, next) {\n      current.setX(current.getX() + shift);\n      current.getFormatterMetrics().freedom.left += shift;\n      current.getFormatterMetrics().freedom.right -= shift;\n      if (prev) prev.getFormatterMetrics().freedom.right += shift;\n      if (next) next.getFormatterMetrics().freedom.left -= shift;\n    }\n    let shift = 0;\n    this.totalShift = 0;\n    contexts.list.forEach((tick, index, list) => {\n      const context = contexts.map[tick];\n      const prevContext = index > 0 ? contexts.map[list[index - 1]] : undefined;\n      const nextContext = index < list.length - 1 ? contexts.map[list[index + 1]] : undefined;\n      move(context, shift, prevContext, nextContext);\n      const cost = -sumArray(context.getTickables().map(t => t.getFormatterMetrics().space.deviation));\n      if (cost > 0) {\n        shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));\n      } else if (cost < 0) {\n        if (nextContext) {\n          shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));\n        } else {\n          shift = 0;\n        }\n      }\n      shift *= alpha;\n      this.totalShift += shift;\n    });\n    return this.evaluate();\n  }\n  postFormat() {\n    this.modifierContexts.forEach(modifierContexts => {\n      modifierContexts.array.forEach(mc => mc.postFormat());\n    });\n    this.tickContexts.list.forEach(tick => {\n      this.tickContexts.map[tick].postFormat();\n    });\n    return this;\n  }\n  joinVoices(voices) {\n    this.createModifierContexts(voices);\n    this.hasMinTotalWidth = false;\n    return this;\n  }\n  format(voices, justifyWidth, options) {\n    const opts = Object.assign({\n      align_rests: false\n    }, options);\n    this.voices = voices;\n    const softmaxFactor = this.formatterOptions.softmaxFactor;\n    if (softmaxFactor) {\n      this.voices.forEach(v => v.setSoftmaxFactor(softmaxFactor));\n    }\n    this.alignRests(voices, opts.align_rests);\n    this.createTickContexts(voices);\n    this.preFormat(justifyWidth, opts.context, voices, opts.stave);\n    if (opts.stave) this.postFormat();\n    return this;\n  }\n  formatToStave(voices, stave, optionsParam) {\n    const options = Object.assign({\n      context: stave.getContext()\n    }, optionsParam);\n    const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - Stave.defaultPadding;\n    L('Formatting voices to width: ', justifyWidth);\n    return this.format(voices, justifyWidth, options);\n  }\n  getTickContext(tick) {\n    var _a;\n    return (_a = this.tickContexts) === null || _a === void 0 ? void 0 : _a.map[tick];\n  }\n}\nFormatter.DEBUG = false;\nexport { Formatter };","map":{"version":3,"names":["Beam","Font","Fraction","ModifierContext","Stave","StaveConnector","Tables","TickContext","isNote","isStaveNote","defined","log","midLine","RuntimeError","sumArray","Voice","createContexts","voices","makeContext","addToContext","length","map","array","list","resolutionMultiplier","tickToContextMap","tickList","contexts","Formatter","getResolutionMultiplier","forEach","voice","voiceIndex","ticksUsed","getTickables","tickable","integerTicks","numerator","newContext","tickID","push","add","getTicks","sort","a","b","L","args","DEBUG","getRestLineForNextNoteGroup","notes","currRestLine","currNoteIndex","compare","nextRestLine","noteIndex","note","isRest","shouldIgnoreTicks","getLineForRest","top","Math","max","bot","min","SimpleFormat","x","paddingBetween","reduce","accumulator","addToModifierContext","tick","addTickable","preFormat","metrics","getMetrics","setX","totalLeftPx","getWidth","totalRightPx","plotDebugging","ctx","formatter","xPos","y1","y2","options","Object","assign","stavePadding","currentMusicFont","lookupMetric","contextGaps","stroke","x1","x2","color","beginPath","setStrokeStyle","setFillStyle","setLineWidth","fillRect","save","setFont","SANS_SERIF","gaps","gap","fillText","round","toString","totalCost","toFixed","totalShift","total","restore","FormatAndDraw","stave","params","auto_beam","align_rests","TIME4_4","setMode","Mode","SOFT","addTickables","beams","applyAndGetBeams","joinVoices","formatToStave","setStave","draw","beam","setContext","getBoundingBox","FormatAndDrawTab","tabstave","tabnotes","autobeam","opts","notevoice","tabvoice","AlignRestsToNotes","tickables","alignAllNotes","alignTuplets","currTickable","index","getTuplet","position","getGlyphProps","toUpperCase","getBeam","props","getKeyProps","line","prevTickable","restLine","setKeyLine","constructor","formatterOptions","globalSoftmax","softmaxFactor","SOFTMAX_FACTOR","maxIterations","justifyWidth","durationStats","minTotalWidth","hasMinTotalWidth","tickContexts","modifierContexts","lossHistory","alignRests","preCalculateMinTotalWidth","unalignedPadding","unalignedCtxCount","wsum","dsum","widths","durations","createTickContexts","contextList","contextMap","context","t","width","value","wavg","wvar","ll","pow","wpads","davg","dvar","dpads","padmax","unalignedPad","getMinTotalWidth","totalTicks","getTotalTicks","equals","getMode","STRICT","isComplete","LCM","createModifierContexts","Map","staveTickToContextMap","get","getStave","set","undefined","fn","contextArray","tContexts","getTickContexts","renderingContext","voicesParam","shift","maxTicks","getMaxTicks","exp","expTicksUsed","evaluate","firstContext","lastContext","calculateIdealDistances","adjustedJustifyWidth","distances","i","getTickablesByVoice","backTickable","prevContext","j","backTick","backVoices","matchingVoices","keys","v","maxNegativeShiftPx","Infinity","expectedDistance","ticks","thisTickable","insideLeftEdge","getX","modLeftPx","leftDisplacedHeadPx","backMetrics","insideRightEdge","notePx","modRightPx","rightDisplacedHeadPx","getVoice","softmax","fromTickable","fromTickablePx","shiftToIdealDistances","idealDistances","centerX","spaceAccum","contextX","ideal","errorPx","negativeShiftPx","abs","getCenterAlignedTickables","setCenterXShift","musicFont","configMinPadding","configMaxPadding","leftPadding","targetWidth","actualWidth","calcMinDistance","mdCalc","di","minDistance","paddingMaxCalc","curTargetWidth","lastTickablePadding","lastTickable","getMaxTickable","getTicksUsed","tickWidth","paddingMax","paddingMin","maxX","iterations","prevTick","prevMetrics","currMetrics","getFormatterMetrics","freedom","left","right","updateStats","duration","space","stats","mean","count","clone","simplify","formatterMetrics","leftNoteEdge","rightNote","rightMetrics","rightNoteEdge","used","totalDeviation","deviation","sqrt","tune","_a","alpha","move","current","prev","next","nextContext","cost","postFormat","mc","format","setSoftmaxFactor","optionsParam","getContext","getNoteEndX","getNoteStartX","defaultPadding","getTickContext"],"sources":["/Users/longgongmeishi/projects/yixian/music-notation-app/node_modules/vexflow/build/esm/src/formatter.js"],"sourcesContent":["import { Beam } from './beam.js';\nimport { Font } from './font.js';\nimport { Fraction } from './fraction.js';\nimport { ModifierContext } from './modifiercontext.js';\nimport { Stave } from './stave.js';\nimport { StaveConnector } from './staveconnector.js';\nimport { Tables } from './tables.js';\nimport { TickContext } from './tickcontext.js';\nimport { isNote, isStaveNote } from './typeguard.js';\nimport { defined, log, midLine, RuntimeError, sumArray } from './util.js';\nimport { Voice } from './voice.js';\nfunction createContexts(voices, makeContext, addToContext) {\n    if (voices.length == 0)\n        return {\n            map: {},\n            array: [],\n            list: [],\n            resolutionMultiplier: 0,\n        };\n    const tickToContextMap = {};\n    const tickList = [];\n    const contexts = [];\n    const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);\n    voices.forEach((voice, voiceIndex) => {\n        const ticksUsed = new Fraction(0, resolutionMultiplier);\n        voice.getTickables().forEach((tickable) => {\n            const integerTicks = ticksUsed.numerator;\n            if (!tickToContextMap[integerTicks]) {\n                const newContext = makeContext({ tickID: integerTicks });\n                contexts.push(newContext);\n                tickToContextMap[integerTicks] = newContext;\n                tickList.push(integerTicks);\n            }\n            addToContext(tickable, tickToContextMap[integerTicks], voiceIndex);\n            ticksUsed.add(tickable.getTicks());\n        });\n    });\n    return {\n        map: tickToContextMap,\n        array: contexts,\n        list: tickList.sort((a, b) => a - b),\n        resolutionMultiplier,\n    };\n}\nfunction L(...args) {\n    if (Formatter.DEBUG)\n        log('Vex.Flow.Formatter', args);\n}\nfunction getRestLineForNextNoteGroup(notes, currRestLine, currNoteIndex, compare) {\n    let nextRestLine = currRestLine;\n    for (let noteIndex = currNoteIndex + 1; noteIndex < notes.length; noteIndex++) {\n        const note = notes[noteIndex];\n        if (isNote(note) && !note.isRest() && !note.shouldIgnoreTicks()) {\n            nextRestLine = note.getLineForRest();\n            break;\n        }\n    }\n    if (compare && currRestLine !== nextRestLine) {\n        const top = Math.max(currRestLine, nextRestLine);\n        const bot = Math.min(currRestLine, nextRestLine);\n        nextRestLine = midLine(top, bot);\n    }\n    return nextRestLine;\n}\nclass Formatter {\n    static SimpleFormat(notes, x = 0, { paddingBetween = 10 } = {}) {\n        notes.reduce((accumulator, note) => {\n            note.addToModifierContext(new ModifierContext());\n            const tick = new TickContext().addTickable(note).preFormat();\n            const metrics = tick.getMetrics();\n            tick.setX(accumulator + metrics.totalLeftPx);\n            return accumulator + tick.getWidth() + metrics.totalRightPx + paddingBetween;\n        }, x);\n    }\n    static plotDebugging(ctx, formatter, xPos, y1, y2, options) {\n        options = Object.assign({ stavePadding: Tables.currentMusicFont().lookupMetric('stave.padding') }, options);\n        const x = xPos + options.stavePadding;\n        const contextGaps = formatter.contextGaps;\n        function stroke(x1, x2, color) {\n            ctx.beginPath();\n            ctx.setStrokeStyle(color);\n            ctx.setFillStyle(color);\n            ctx.setLineWidth(1);\n            ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);\n        }\n        ctx.save();\n        ctx.setFont(Font.SANS_SERIF, 8);\n        contextGaps.gaps.forEach((gap) => {\n            stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');\n            ctx.setFillStyle('green');\n            ctx.fillText(Math.round(gap.x2 - gap.x1).toString(), x + gap.x1, y2 + 12);\n        });\n        ctx.setFillStyle('red');\n        ctx.fillText(`Loss: ${(formatter.totalCost || 0).toFixed(2)} Shift: ${(formatter.totalShift || 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);\n        ctx.restore();\n    }\n    static FormatAndDraw(ctx, stave, notes, params) {\n        let options = {\n            auto_beam: false,\n            align_rests: false,\n        };\n        if (typeof params === 'object') {\n            options = Object.assign(Object.assign({}, options), params);\n        }\n        else if (typeof params === 'boolean') {\n            options.auto_beam = params;\n        }\n        const voice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes);\n        const beams = options.auto_beam ? Beam.applyAndGetBeams(voice) : [];\n        new Formatter()\n            .joinVoices([voice])\n            .formatToStave([voice], stave, { align_rests: options.align_rests, stave });\n        voice.setStave(stave).draw(ctx, stave);\n        beams.forEach((beam) => beam.setContext(ctx).draw());\n        return voice.getBoundingBox();\n    }\n    static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autobeam, params) {\n        let opts = {\n            auto_beam: autobeam,\n            align_rests: false,\n        };\n        if (typeof params === 'object') {\n            opts = Object.assign(Object.assign({}, opts), params);\n        }\n        else if (typeof params === 'boolean') {\n            opts.auto_beam = params;\n        }\n        const notevoice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes);\n        const tabvoice = new Voice(Tables.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(tabnotes);\n        const beams = opts.auto_beam ? Beam.applyAndGetBeams(notevoice) : [];\n        new Formatter()\n            .joinVoices([notevoice])\n            .joinVoices([tabvoice])\n            .formatToStave([notevoice, tabvoice], stave, { align_rests: opts.align_rests });\n        notevoice.draw(ctx, stave);\n        tabvoice.draw(ctx, tabstave);\n        beams.forEach((beam) => beam.setContext(ctx).draw());\n        new StaveConnector(stave, tabstave).setContext(ctx).draw();\n    }\n    static AlignRestsToNotes(tickables, alignAllNotes, alignTuplets) {\n        tickables.forEach((currTickable, index) => {\n            if (isStaveNote(currTickable) && currTickable.isRest()) {\n                if (currTickable.getTuplet() && !alignTuplets) {\n                    return;\n                }\n                const position = currTickable.getGlyphProps().position.toUpperCase();\n                if (position !== 'R/4' && position !== 'B/4') {\n                    return;\n                }\n                if (alignAllNotes || currTickable.getBeam()) {\n                    const props = currTickable.getKeyProps()[0];\n                    if (index === 0) {\n                        props.line = getRestLineForNextNoteGroup(tickables, props.line, index, false);\n                    }\n                    else if (index > 0 && index < tickables.length) {\n                        const prevTickable = tickables[index - 1];\n                        if (isStaveNote(prevTickable)) {\n                            if (prevTickable.isRest()) {\n                                props.line = prevTickable.getKeyProps()[0].line;\n                            }\n                            else {\n                                const restLine = prevTickable.getLineForRest();\n                                props.line = getRestLineForNextNoteGroup(tickables, restLine, index, true);\n                            }\n                        }\n                    }\n                    currTickable.setKeyLine(0, props.line);\n                }\n            }\n        });\n    }\n    constructor(options) {\n        this.formatterOptions = Object.assign({ globalSoftmax: false, softmaxFactor: Tables.SOFTMAX_FACTOR, maxIterations: 5 }, options);\n        this.justifyWidth = 0;\n        this.totalCost = 0;\n        this.totalShift = 0;\n        this.durationStats = {};\n        this.minTotalWidth = 0;\n        this.hasMinTotalWidth = false;\n        this.tickContexts = {\n            map: {},\n            array: [],\n            list: [],\n            resolutionMultiplier: 0,\n        };\n        this.modifierContexts = [];\n        this.contextGaps = {\n            total: 0,\n            gaps: [],\n        };\n        this.voices = [];\n        this.lossHistory = [];\n    }\n    alignRests(voices, alignAllNotes) {\n        if (!voices || !voices.length) {\n            throw new RuntimeError('BadArgument', 'No voices to format rests');\n        }\n        voices.forEach((voice) => Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));\n    }\n    preCalculateMinTotalWidth(voices) {\n        const unalignedPadding = Tables.currentMusicFont().lookupMetric('stave.unalignedNotePadding');\n        let unalignedCtxCount = 0;\n        let wsum = 0;\n        let dsum = 0;\n        const widths = [];\n        const durations = [];\n        if (this.hasMinTotalWidth)\n            return this.minTotalWidth;\n        if (!voices) {\n            throw new RuntimeError('BadArgument', \"'voices' required to run preCalculateMinTotalWidth\");\n        }\n        this.createTickContexts(voices);\n        const { list: contextList, map: contextMap } = this.tickContexts;\n        this.minTotalWidth = 0;\n        contextList.forEach((tick) => {\n            const context = contextMap[tick];\n            context.preFormat();\n            if (context.getTickables().length < voices.length) {\n                unalignedCtxCount += 1;\n            }\n            context.getTickables().forEach((t) => {\n                wsum += t.getMetrics().width;\n                dsum += t.getTicks().value();\n                widths.push(t.getMetrics().width);\n                durations.push(t.getTicks().value());\n            });\n            const width = context.getWidth();\n            this.minTotalWidth += width;\n        });\n        this.hasMinTotalWidth = true;\n        const wavg = wsum > 0 ? wsum / widths.length : 1 / widths.length;\n        const wvar = sumArray(widths.map((ll) => Math.pow(ll - wavg, 2)));\n        const wpads = Math.pow(wvar / widths.length, 0.5) / wavg;\n        const davg = dsum / durations.length;\n        const dvar = sumArray(durations.map((ll) => Math.pow(ll - davg, 2)));\n        const dpads = Math.pow(dvar / durations.length, 0.5) / davg;\n        const padmax = Math.max(dpads, wpads) * contextList.length * unalignedPadding;\n        const unalignedPad = unalignedPadding * unalignedCtxCount;\n        return this.minTotalWidth + Math.max(unalignedPad, padmax);\n    }\n    getMinTotalWidth() {\n        if (!this.hasMinTotalWidth) {\n            throw new RuntimeError('NoMinTotalWidth', \"Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'\");\n        }\n        return this.minTotalWidth;\n    }\n    static getResolutionMultiplier(voices) {\n        if (!voices || !voices.length) {\n            throw new RuntimeError('BadArgument', 'No voices to format');\n        }\n        const totalTicks = voices[0].getTotalTicks();\n        const resolutionMultiplier = voices.reduce((accumulator, voice) => {\n            if (!voice.getTotalTicks().equals(totalTicks)) {\n                throw new RuntimeError('TickMismatch', 'Voices should have same total note duration in ticks.');\n            }\n            if (voice.getMode() === Voice.Mode.STRICT && !voice.isComplete()) {\n                throw new RuntimeError('IncompleteVoice', 'Voice does not have enough notes.');\n            }\n            return Math.max(accumulator, Fraction.LCM(accumulator, voice.getResolutionMultiplier()));\n        }, 1);\n        return resolutionMultiplier;\n    }\n    createModifierContexts(voices) {\n        if (voices.length == 0)\n            return;\n        const resolutionMultiplier = Formatter.getResolutionMultiplier(voices);\n        const tickToContextMap = new Map();\n        const contexts = [];\n        voices.forEach((voice) => {\n            const ticksUsed = new Fraction(0, resolutionMultiplier);\n            voice.getTickables().forEach((tickable) => {\n                const integerTicks = ticksUsed.numerator;\n                let staveTickToContextMap = tickToContextMap.get(tickable.getStave());\n                if (!staveTickToContextMap) {\n                    tickToContextMap.set(tickable.getStave(), {});\n                    staveTickToContextMap = tickToContextMap.get(tickable.getStave());\n                }\n                if (!(staveTickToContextMap ? staveTickToContextMap[integerTicks] : undefined)) {\n                    const newContext = new ModifierContext();\n                    contexts.push(newContext);\n                    staveTickToContextMap[integerTicks] = newContext;\n                }\n                tickable.addToModifierContext(staveTickToContextMap[integerTicks]);\n                ticksUsed.add(tickable.getTicks());\n            });\n        });\n        this.modifierContexts.push({\n            map: tickToContextMap,\n            array: contexts,\n            resolutionMultiplier,\n        });\n    }\n    createTickContexts(voices) {\n        const fn = (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex);\n        const contexts = createContexts(voices, (tick) => new TickContext(tick), fn);\n        this.tickContexts = contexts;\n        const contextArray = this.tickContexts.array;\n        contextArray.forEach((context) => {\n            context.tContexts = contextArray;\n        });\n        return contexts;\n    }\n    getTickContexts() {\n        return this.tickContexts;\n    }\n    preFormat(justifyWidth = 0, renderingContext, voicesParam, stave) {\n        const contexts = this.tickContexts;\n        if (!contexts) {\n            throw new RuntimeError('NoTickContexts', 'preFormat requires TickContexts');\n        }\n        const { list: contextList, map: contextMap } = contexts;\n        this.lossHistory = [];\n        if (voicesParam && stave) {\n            voicesParam.forEach((voice) => voice.setStave(stave).preFormat());\n        }\n        let x = 0;\n        let shift = 0;\n        this.minTotalWidth = 0;\n        let totalTicks = 0;\n        contextList.forEach((tick) => {\n            const context = contextMap[tick];\n            context.preFormat();\n            const width = context.getWidth();\n            this.minTotalWidth += width;\n            const maxTicks = context.getMaxTicks().value();\n            totalTicks += maxTicks;\n            const metrics = context.getMetrics();\n            x = x + shift + metrics.totalLeftPx;\n            context.setX(x);\n            shift = width - metrics.totalLeftPx;\n        });\n        const { globalSoftmax, softmaxFactor, maxIterations } = this.formatterOptions;\n        const exp = (tick) => Math.pow(softmaxFactor, (contextMap[tick].getMaxTicks().value() / totalTicks));\n        const expTicksUsed = sumArray(contextList.map(exp));\n        this.minTotalWidth = x + shift;\n        this.hasMinTotalWidth = true;\n        if (justifyWidth <= 0)\n            return this.evaluate();\n        const firstContext = contextMap[contextList[0]];\n        const lastContext = contextMap[contextList[contextList.length - 1]];\n        function calculateIdealDistances(adjustedJustifyWidth) {\n            const distances = contextList.map((tick, i) => {\n                const context = contextMap[tick];\n                const voices = context.getTickablesByVoice();\n                let backTickable;\n                if (i > 0) {\n                    const prevContext = contextMap[contextList[i - 1]];\n                    for (let j = i - 1; j >= 0; j--) {\n                        const backTick = contextMap[contextList[j]];\n                        const backVoices = backTick.getTickablesByVoice();\n                        const matchingVoices = [];\n                        Object.keys(voices).forEach((v) => {\n                            if (backVoices[v]) {\n                                matchingVoices.push(v);\n                            }\n                        });\n                        if (matchingVoices.length > 0) {\n                            let maxTicks = 0;\n                            let maxNegativeShiftPx = Infinity;\n                            let expectedDistance = 0;\n                            matchingVoices.forEach((v) => {\n                                const ticks = backVoices[v].getTicks().value();\n                                if (ticks > maxTicks) {\n                                    backTickable = backVoices[v];\n                                    maxTicks = ticks;\n                                }\n                                const thisTickable = voices[v];\n                                const insideLeftEdge = thisTickable.getX() -\n                                    (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);\n                                const backMetrics = backVoices[v].getMetrics();\n                                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx;\n                                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);\n                            });\n                            maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - (prevContext.getX() + adjustedJustifyWidth * 0.05));\n                            if (globalSoftmax) {\n                                const t = totalTicks;\n                                expectedDistance = (Math.pow(softmaxFactor, (maxTicks / t)) / expTicksUsed) * adjustedJustifyWidth;\n                            }\n                            else if (typeof backTickable !== 'undefined') {\n                                expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;\n                            }\n                            return {\n                                expectedDistance,\n                                maxNegativeShiftPx,\n                                fromTickable: backTickable,\n                            };\n                        }\n                    }\n                }\n                return { expectedDistance: 0, fromTickablePx: 0, maxNegativeShiftPx: 0 };\n            });\n            return distances;\n        }\n        function shiftToIdealDistances(idealDistances) {\n            const centerX = adjustedJustifyWidth / 2;\n            let spaceAccum = 0;\n            contextList.forEach((tick, index) => {\n                const context = contextMap[tick];\n                if (index > 0) {\n                    const contextX = context.getX();\n                    const ideal = idealDistances[index];\n                    const errorPx = defined(ideal.fromTickable).getX() + ideal.expectedDistance - (contextX + spaceAccum);\n                    let negativeShiftPx = 0;\n                    if (errorPx > 0) {\n                        spaceAccum += errorPx;\n                    }\n                    else if (errorPx < 0) {\n                        negativeShiftPx = Math.min(ideal.maxNegativeShiftPx, Math.abs(errorPx));\n                        spaceAccum += -negativeShiftPx;\n                    }\n                    context.setX(contextX + spaceAccum);\n                }\n                context.getCenterAlignedTickables().forEach((tickable) => {\n                    tickable.setCenterXShift(centerX - context.getX());\n                });\n            });\n            return lastContext.getX() - firstContext.getX();\n        }\n        const adjustedJustifyWidth = justifyWidth -\n            lastContext.getMetrics().notePx -\n            lastContext.getMetrics().totalRightPx -\n            firstContext.getMetrics().totalLeftPx;\n        const musicFont = Tables.currentMusicFont();\n        const configMinPadding = musicFont.lookupMetric('stave.endPaddingMin');\n        const configMaxPadding = musicFont.lookupMetric('stave.endPaddingMax');\n        const leftPadding = musicFont.lookupMetric('stave.padding');\n        let targetWidth = adjustedJustifyWidth;\n        const distances = calculateIdealDistances(targetWidth);\n        let actualWidth = shiftToIdealDistances(distances);\n        if (contextList.length === 1)\n            return 0;\n        const calcMinDistance = (targetWidth, distances) => {\n            let mdCalc = targetWidth / 2;\n            if (distances.length > 1) {\n                for (let di = 1; di < distances.length; ++di) {\n                    mdCalc = Math.min(distances[di].expectedDistance / 2, mdCalc);\n                }\n            }\n            return mdCalc;\n        };\n        const minDistance = calcMinDistance(targetWidth, distances);\n        const paddingMaxCalc = (curTargetWidth) => {\n            let lastTickablePadding = 0;\n            const lastTickable = lastContext && lastContext.getMaxTickable();\n            if (lastTickable) {\n                const voice = lastTickable.getVoice();\n                if (voice.getTicksUsed().value() > voice.getTotalTicks().value()) {\n                    return configMaxPadding * 2 < minDistance ? minDistance : configMaxPadding;\n                }\n                const tickWidth = lastTickable.getWidth();\n                lastTickablePadding =\n                    voice.softmax(lastContext.getMaxTicks().value()) * curTargetWidth - (tickWidth + leftPadding);\n            }\n            return configMaxPadding * 2 < lastTickablePadding ? lastTickablePadding : configMaxPadding;\n        };\n        let paddingMax = paddingMaxCalc(targetWidth);\n        let paddingMin = paddingMax - (configMaxPadding - configMinPadding);\n        const maxX = adjustedJustifyWidth - paddingMin;\n        let iterations = maxIterations;\n        while ((actualWidth > maxX && iterations > 0) || (actualWidth + paddingMax < maxX && iterations > 1)) {\n            targetWidth -= actualWidth - maxX;\n            paddingMax = paddingMaxCalc(targetWidth);\n            paddingMin = paddingMax - (configMaxPadding - configMinPadding);\n            actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n            iterations--;\n        }\n        this.justifyWidth = justifyWidth;\n        return this.evaluate();\n    }\n    evaluate() {\n        const contexts = this.tickContexts;\n        const justifyWidth = this.justifyWidth;\n        this.contextGaps = { total: 0, gaps: [] };\n        contexts.list.forEach((tick, index) => {\n            if (index === 0)\n                return;\n            const prevTick = contexts.list[index - 1];\n            const prevContext = contexts.map[prevTick];\n            const context = contexts.map[tick];\n            const prevMetrics = prevContext.getMetrics();\n            const currMetrics = context.getMetrics();\n            const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx;\n            const insideLeftEdge = context.getX() - currMetrics.totalLeftPx;\n            const gap = insideLeftEdge - insideRightEdge;\n            this.contextGaps.total += gap;\n            this.contextGaps.gaps.push({ x1: insideRightEdge, x2: insideLeftEdge });\n            context.getFormatterMetrics().freedom.left = gap;\n            prevContext.getFormatterMetrics().freedom.right = gap;\n        });\n        this.durationStats = {};\n        const durationStats = this.durationStats;\n        function updateStats(duration, space) {\n            const stats = durationStats[duration];\n            if (stats === undefined) {\n                durationStats[duration] = { mean: space, count: 1 };\n            }\n            else {\n                stats.count += 1;\n                stats.mean = (stats.mean + space) / 2;\n            }\n        }\n        this.voices.forEach((voice) => {\n            voice.getTickables().forEach((note, i, notes) => {\n                const duration = note.getTicks().clone().simplify().toString();\n                const metrics = note.getMetrics();\n                const formatterMetrics = note.getFormatterMetrics();\n                const leftNoteEdge = note.getX() + metrics.notePx + metrics.modRightPx + metrics.rightDisplacedHeadPx;\n                let space = 0;\n                if (i < notes.length - 1) {\n                    const rightNote = notes[i + 1];\n                    const rightMetrics = rightNote.getMetrics();\n                    const rightNoteEdge = rightNote.getX() - rightMetrics.modLeftPx - rightMetrics.leftDisplacedHeadPx;\n                    space = rightNoteEdge - leftNoteEdge;\n                    formatterMetrics.space.used = rightNote.getX() - note.getX();\n                    rightNote.getFormatterMetrics().freedom.left = space;\n                }\n                else {\n                    space = justifyWidth - leftNoteEdge;\n                    formatterMetrics.space.used = justifyWidth - note.getX();\n                }\n                formatterMetrics.freedom.right = space;\n                updateStats(duration, formatterMetrics.space.used);\n            });\n        });\n        let totalDeviation = 0;\n        this.voices.forEach((voice) => {\n            voice.getTickables().forEach((note) => {\n                const duration = note.getTicks().clone().simplify().toString();\n                const metrics = note.getFormatterMetrics();\n                metrics.space.mean = durationStats[duration].mean;\n                metrics.duration = duration;\n                metrics.iterations += 1;\n                metrics.space.deviation = metrics.space.used - metrics.space.mean;\n                totalDeviation += Math.pow(metrics.space.deviation, 2);\n            });\n        });\n        this.totalCost = Math.sqrt(totalDeviation);\n        this.lossHistory.push(this.totalCost);\n        return this.totalCost;\n    }\n    tune(options) {\n        var _a;\n        const contexts = this.tickContexts;\n        if (!contexts) {\n            return 0;\n        }\n        const alpha = (_a = options === null || options === void 0 ? void 0 : options.alpha) !== null && _a !== void 0 ? _a : 0.5;\n        function move(current, shift, prev, next) {\n            current.setX(current.getX() + shift);\n            current.getFormatterMetrics().freedom.left += shift;\n            current.getFormatterMetrics().freedom.right -= shift;\n            if (prev)\n                prev.getFormatterMetrics().freedom.right += shift;\n            if (next)\n                next.getFormatterMetrics().freedom.left -= shift;\n        }\n        let shift = 0;\n        this.totalShift = 0;\n        contexts.list.forEach((tick, index, list) => {\n            const context = contexts.map[tick];\n            const prevContext = index > 0 ? contexts.map[list[index - 1]] : undefined;\n            const nextContext = index < list.length - 1 ? contexts.map[list[index + 1]] : undefined;\n            move(context, shift, prevContext, nextContext);\n            const cost = -sumArray(context.getTickables().map((t) => t.getFormatterMetrics().space.deviation));\n            if (cost > 0) {\n                shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));\n            }\n            else if (cost < 0) {\n                if (nextContext) {\n                    shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));\n                }\n                else {\n                    shift = 0;\n                }\n            }\n            shift *= alpha;\n            this.totalShift += shift;\n        });\n        return this.evaluate();\n    }\n    postFormat() {\n        this.modifierContexts.forEach((modifierContexts) => {\n            modifierContexts.array.forEach((mc) => mc.postFormat());\n        });\n        this.tickContexts.list.forEach((tick) => {\n            this.tickContexts.map[tick].postFormat();\n        });\n        return this;\n    }\n    joinVoices(voices) {\n        this.createModifierContexts(voices);\n        this.hasMinTotalWidth = false;\n        return this;\n    }\n    format(voices, justifyWidth, options) {\n        const opts = Object.assign({ align_rests: false }, options);\n        this.voices = voices;\n        const softmaxFactor = this.formatterOptions.softmaxFactor;\n        if (softmaxFactor) {\n            this.voices.forEach((v) => v.setSoftmaxFactor(softmaxFactor));\n        }\n        this.alignRests(voices, opts.align_rests);\n        this.createTickContexts(voices);\n        this.preFormat(justifyWidth, opts.context, voices, opts.stave);\n        if (opts.stave)\n            this.postFormat();\n        return this;\n    }\n    formatToStave(voices, stave, optionsParam) {\n        const options = Object.assign({ context: stave.getContext() }, optionsParam);\n        const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - Stave.defaultPadding;\n        L('Formatting voices to width: ', justifyWidth);\n        return this.format(voices, justifyWidth, options);\n    }\n    getTickContext(tick) {\n        var _a;\n        return (_a = this.tickContexts) === null || _a === void 0 ? void 0 : _a.map[tick];\n    }\n}\nFormatter.DEBUG = false;\nexport { Formatter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}